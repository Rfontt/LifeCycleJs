(() => {
  var __commonJS = (callback, module) => () => {
    if (!module) {
      module = {exports: {}};
      callback(module.exports, module);
    }
    return module.exports;
  };

  // node_modules/type/value/is.js
  var require_is = __commonJS((exports, module) => {
    "use strict";
    var _undefined = void 0;
    module.exports = function(value) {
      return value !== _undefined && value !== null;
    };
  });

  // node_modules/type/object/is.js
  var require_is2 = __commonJS((exports, module) => {
    "use strict";
    var isValue = require_is();
    var possibleTypes = {object: true, function: true, undefined: true};
    module.exports = function(value) {
      if (!isValue(value))
        return false;
      return hasOwnProperty.call(possibleTypes, typeof value);
    };
  });

  // node_modules/type/prototype/is.js
  var require_is3 = __commonJS((exports, module) => {
    "use strict";
    var isObject = require_is2();
    module.exports = function(value) {
      if (!isObject(value))
        return false;
      try {
        if (!value.constructor)
          return false;
        return value.constructor.prototype === value;
      } catch (error) {
        return false;
      }
    };
  });

  // node_modules/type/function/is.js
  var require_is4 = __commonJS((exports, module) => {
    "use strict";
    var isPrototype = require_is3();
    module.exports = function(value) {
      if (typeof value !== "function")
        return false;
      if (!hasOwnProperty.call(value, "length"))
        return false;
      try {
        if (typeof value.length !== "number")
          return false;
        if (typeof value.call !== "function")
          return false;
        if (typeof value.apply !== "function")
          return false;
      } catch (error) {
        return false;
      }
      return !isPrototype(value);
    };
  });

  // node_modules/type/plain-function/is.js
  var require_is5 = __commonJS((exports, module) => {
    "use strict";
    var isFunction = require_is4();
    var classRe = /^\s*class[\s{/}]/;
    var functionToString = Function.prototype.toString;
    module.exports = function(value) {
      if (!isFunction(value))
        return false;
      if (classRe.test(functionToString.call(value)))
        return false;
      return true;
    };
  });

  // node_modules/es5-ext/object/assign/is-implemented.js
  var require_is_implemented = __commonJS((exports, module) => {
    "use strict";
    module.exports = function() {
      var assign = Object.assign, obj;
      if (typeof assign !== "function")
        return false;
      obj = {foo: "raz"};
      assign(obj, {bar: "dwa"}, {trzy: "trzy"});
      return obj.foo + obj.bar + obj.trzy === "razdwatrzy";
    };
  });

  // node_modules/es5-ext/object/keys/is-implemented.js
  var require_is_implemented2 = __commonJS((exports, module) => {
    "use strict";
    module.exports = function() {
      try {
        Object.keys("primitive");
        return true;
      } catch (e) {
        return false;
      }
    };
  });

  // node_modules/es5-ext/function/noop.js
  var require_noop = __commonJS((exports, module) => {
    "use strict";
    module.exports = function() {
    };
  });

  // node_modules/es5-ext/object/is-value.js
  var require_is_value = __commonJS((exports, module) => {
    "use strict";
    var _undefined = require_noop()();
    module.exports = function(val) {
      return val !== _undefined && val !== null;
    };
  });

  // node_modules/es5-ext/object/keys/shim.js
  var require_shim = __commonJS((exports, module) => {
    "use strict";
    var isValue = require_is_value();
    var keys = Object.keys;
    module.exports = function(object) {
      return keys(isValue(object) ? Object(object) : object);
    };
  });

  // node_modules/es5-ext/object/keys/index.js
  var require_keys = __commonJS((exports, module) => {
    "use strict";
    module.exports = require_is_implemented2()() ? Object.keys : require_shim();
  });

  // node_modules/es5-ext/object/valid-value.js
  var require_valid_value = __commonJS((exports, module) => {
    "use strict";
    var isValue = require_is_value();
    module.exports = function(value) {
      if (!isValue(value))
        throw new TypeError("Cannot use null or undefined");
      return value;
    };
  });

  // node_modules/es5-ext/object/assign/shim.js
  var require_shim2 = __commonJS((exports, module) => {
    "use strict";
    var keys = require_keys();
    var value = require_valid_value();
    var max = Math.max;
    module.exports = function(dest, src) {
      var error, i, length = max(arguments.length, 2), assign;
      dest = Object(value(dest));
      assign = function(key) {
        try {
          dest[key] = src[key];
        } catch (e) {
          if (!error)
            error = e;
        }
      };
      for (i = 1; i < length; ++i) {
        src = arguments[i];
        keys(src).forEach(assign);
      }
      if (error !== void 0)
        throw error;
      return dest;
    };
  });

  // node_modules/es5-ext/object/assign/index.js
  var require_assign = __commonJS((exports, module) => {
    "use strict";
    module.exports = require_is_implemented()() ? Object.assign : require_shim2();
  });

  // node_modules/es5-ext/object/normalize-options.js
  var require_normalize_options = __commonJS((exports, module) => {
    "use strict";
    var isValue = require_is_value();
    var forEach = Array.prototype.forEach;
    var create = Object.create;
    var process2 = function(src, obj) {
      var key;
      for (key in src)
        obj[key] = src[key];
    };
    module.exports = function(opts1) {
      var result = create(null);
      forEach.call(arguments, function(options) {
        if (!isValue(options))
          return;
        process2(Object(options), result);
      });
      return result;
    };
  });

  // node_modules/es5-ext/string/#/contains/is-implemented.js
  var require_is_implemented3 = __commonJS((exports, module) => {
    "use strict";
    var str = "razdwatrzy";
    module.exports = function() {
      if (typeof str.contains !== "function")
        return false;
      return str.contains("dwa") === true && str.contains("foo") === false;
    };
  });

  // node_modules/es5-ext/string/#/contains/shim.js
  var require_shim3 = __commonJS((exports, module) => {
    "use strict";
    var indexOf = String.prototype.indexOf;
    module.exports = function(searchString) {
      return indexOf.call(this, searchString, arguments[1]) > -1;
    };
  });

  // node_modules/es5-ext/string/#/contains/index.js
  var require_contains = __commonJS((exports, module) => {
    "use strict";
    module.exports = require_is_implemented3()() ? String.prototype.contains : require_shim3();
  });

  // node_modules/d/index.js
  var require_d = __commonJS((exports, module) => {
    "use strict";
    var isValue = require_is();
    var isPlainFunction = require_is5();
    var assign = require_assign();
    var normalizeOpts = require_normalize_options();
    var contains = require_contains();
    var d = module.exports = function(dscr, value) {
      var c, e, w, options, desc;
      if (arguments.length < 2 || typeof dscr !== "string") {
        options = value;
        value = dscr;
        dscr = null;
      } else {
        options = arguments[2];
      }
      if (isValue(dscr)) {
        c = contains.call(dscr, "c");
        e = contains.call(dscr, "e");
        w = contains.call(dscr, "w");
      } else {
        c = w = true;
        e = false;
      }
      desc = {value, configurable: c, enumerable: e, writable: w};
      return !options ? desc : assign(normalizeOpts(options), desc);
    };
    d.gs = function(dscr, get, set) {
      var c, e, options, desc;
      if (typeof dscr !== "string") {
        options = set;
        set = get;
        get = dscr;
        dscr = null;
      } else {
        options = arguments[3];
      }
      if (!isValue(get)) {
        get = void 0;
      } else if (!isPlainFunction(get)) {
        options = get;
        get = set = void 0;
      } else if (!isValue(set)) {
        set = void 0;
      } else if (!isPlainFunction(set)) {
        options = set;
        set = void 0;
      }
      if (isValue(dscr)) {
        c = contains.call(dscr, "c");
        e = contains.call(dscr, "e");
      } else {
        c = true;
        e = false;
      }
      desc = {get, set, configurable: c, enumerable: e};
      return !options ? desc : assign(normalizeOpts(options), desc);
    };
  });

  // node_modules/es5-ext/object/valid-callable.js
  var require_valid_callable = __commonJS((exports, module) => {
    "use strict";
    module.exports = function(fn) {
      if (typeof fn !== "function")
        throw new TypeError(fn + " is not a function");
      return fn;
    };
  });

  // node_modules/event-emitter/index.js
  var require_event_emitter = __commonJS((exports, module) => {
    "use strict";
    var d = require_d();
    var callable = require_valid_callable();
    var apply = Function.prototype.apply;
    var call = Function.prototype.call;
    var create = Object.create;
    var defineProperty = Object.defineProperty;
    var defineProperties = Object.defineProperties;
    var hasOwnProperty2 = Object.prototype.hasOwnProperty;
    var descriptor = {configurable: true, enumerable: false, writable: true};
    var on;
    var once;
    var off;
    var emit;
    var methods;
    var descriptors;
    var base;
    on = function(type, listener) {
      var data;
      callable(listener);
      if (!hasOwnProperty2.call(this, "__ee__")) {
        data = descriptor.value = create(null);
        defineProperty(this, "__ee__", descriptor);
        descriptor.value = null;
      } else {
        data = this.__ee__;
      }
      if (!data[type])
        data[type] = listener;
      else if (typeof data[type] === "object")
        data[type].push(listener);
      else
        data[type] = [data[type], listener];
      return this;
    };
    once = function(type, listener) {
      var once2, self2;
      callable(listener);
      self2 = this;
      on.call(this, type, once2 = function() {
        off.call(self2, type, once2);
        apply.call(listener, this, arguments);
      });
      once2.__eeOnceListener__ = listener;
      return this;
    };
    off = function(type, listener) {
      var data, listeners, candidate, i;
      callable(listener);
      if (!hasOwnProperty2.call(this, "__ee__"))
        return this;
      data = this.__ee__;
      if (!data[type])
        return this;
      listeners = data[type];
      if (typeof listeners === "object") {
        for (i = 0; candidate = listeners[i]; ++i) {
          if (candidate === listener || candidate.__eeOnceListener__ === listener) {
            if (listeners.length === 2)
              data[type] = listeners[i ? 0 : 1];
            else
              listeners.splice(i, 1);
          }
        }
      } else {
        if (listeners === listener || listeners.__eeOnceListener__ === listener) {
          delete data[type];
        }
      }
      return this;
    };
    emit = function(type) {
      var i, l, listener, listeners, args;
      if (!hasOwnProperty2.call(this, "__ee__"))
        return;
      listeners = this.__ee__[type];
      if (!listeners)
        return;
      if (typeof listeners === "object") {
        l = arguments.length;
        args = new Array(l - 1);
        for (i = 1; i < l; ++i)
          args[i - 1] = arguments[i];
        listeners = listeners.slice();
        for (i = 0; listener = listeners[i]; ++i) {
          apply.call(listener, this, args);
        }
      } else {
        switch (arguments.length) {
          case 1:
            call.call(listeners, this);
            break;
          case 2:
            call.call(listeners, this, arguments[1]);
            break;
          case 3:
            call.call(listeners, this, arguments[1], arguments[2]);
            break;
          default:
            l = arguments.length;
            args = new Array(l - 1);
            for (i = 1; i < l; ++i) {
              args[i - 1] = arguments[i];
            }
            apply.call(listeners, this, args);
        }
      }
    };
    methods = {
      on,
      once,
      off,
      emit
    };
    descriptors = {
      on: d(on),
      once: d(once),
      off: d(off),
      emit: d(emit)
    };
    base = defineProperties({}, descriptors);
    module.exports = exports = function(o) {
      return o == null ? create(base) : defineProperties(Object(o), descriptors);
    };
    exports.methods = methods;
  });

  // node_modules/@sinonjs/commons/lib/global.js
  var require_global = __commonJS((exports, module) => {
    "use strict";
    var globalObject;
    if (typeof global !== "undefined") {
      globalObject = global;
    } else if (typeof window !== "undefined") {
      globalObject = window;
    } else {
      globalObject = self;
    }
    module.exports = globalObject;
  });

  // node_modules/@sinonjs/commons/lib/prototypes/copy-prototype.js
  var require_copy_prototype = __commonJS((exports, module) => {
    "use strict";
    var call = Function.call;
    module.exports = function copyPrototypeMethods(prototype) {
      return Object.getOwnPropertyNames(prototype).reduce(function(result, name) {
        if (name !== "size" && name !== "caller" && name !== "callee" && name !== "arguments" && typeof prototype[name] === "function") {
          result[name] = call.bind(prototype[name]);
        }
        return result;
      }, Object.create(null));
    };
  });

  // node_modules/@sinonjs/commons/lib/prototypes/array.js
  var require_array = __commonJS((exports, module) => {
    "use strict";
    var copyPrototype = require_copy_prototype();
    module.exports = copyPrototype(Array.prototype);
  });

  // node_modules/@sinonjs/commons/lib/called-in-order.js
  var require_called_in_order = __commonJS((exports, module) => {
    "use strict";
    var every = require_array().every;
    function hasCallsLeft(callMap, spy) {
      if (callMap[spy.id] === void 0) {
        callMap[spy.id] = 0;
      }
      return callMap[spy.id] < spy.callCount;
    }
    function checkAdjacentCalls(callMap, spy, index, spies) {
      var calledBeforeNext = true;
      if (index !== spies.length - 1) {
        calledBeforeNext = spy.calledBefore(spies[index + 1]);
      }
      if (hasCallsLeft(callMap, spy) && calledBeforeNext) {
        callMap[spy.id] += 1;
        return true;
      }
      return false;
    }
    function calledInOrder(spies) {
      var callMap = {};
      var _spies = arguments.length > 1 ? arguments : spies;
      return every(_spies, checkAdjacentCalls.bind(null, callMap));
    }
    module.exports = calledInOrder;
  });

  // node_modules/@sinonjs/commons/lib/function-name.js
  var require_function_name = __commonJS((exports, module) => {
    "use strict";
    module.exports = function functionName(func) {
      if (!func) {
        return "";
      }
      try {
        return func.displayName || func.name || (String(func).match(/function ([^\s(]+)/) || [])[1];
      } catch (e) {
        return "";
      }
    };
  });

  // node_modules/@sinonjs/commons/lib/class-name.js
  var require_class_name = __commonJS((exports, module) => {
    "use strict";
    var functionName = require_function_name();
    function className(value) {
      return value.constructor && value.constructor.name || typeof value.constructor === "function" && functionName(value.constructor) || null;
    }
    module.exports = className;
  });

  // node_modules/@sinonjs/commons/lib/deprecated.js
  var require_deprecated = __commonJS((exports) => {
    "use strict";
    exports.wrap = function(func, msg) {
      var wrapped = function() {
        exports.printWarning(msg);
        return func.apply(this, arguments);
      };
      if (func.prototype) {
        wrapped.prototype = func.prototype;
      }
      return wrapped;
    };
    exports.defaultMsg = function(packageName, funcName) {
      return packageName + "." + funcName + " is deprecated and will be removed from the public API in a future version of " + packageName + ".";
    };
    exports.printWarning = function(msg) {
      if (typeof process === "object" && process.emitWarning) {
        process.emitWarning(msg);
      } else if (console.info) {
        console.info(msg);
      } else {
        console.log(msg);
      }
    };
  });

  // node_modules/@sinonjs/commons/lib/every.js
  var require_every = __commonJS((exports, module) => {
    "use strict";
    module.exports = function every(obj, fn) {
      var pass = true;
      try {
        obj.forEach(function() {
          if (!fn.apply(this, arguments)) {
            throw new Error();
          }
        });
      } catch (e) {
        pass = false;
      }
      return pass;
    };
  });

  // node_modules/@sinonjs/commons/lib/order-by-first-call.js
  var require_order_by_first_call = __commonJS((exports, module) => {
    "use strict";
    var sort = require_array().sort;
    var slice = require_array().slice;
    function comparator(a, b) {
      var aCall = a.getCall(0);
      var bCall = b.getCall(0);
      var aId = aCall && aCall.callId || -1;
      var bId = bCall && bCall.callId || -1;
      return aId < bId ? -1 : 1;
    }
    function orderByFirstCall(spies) {
      return sort(slice(spies), comparator);
    }
    module.exports = orderByFirstCall;
  });

  // node_modules/@sinonjs/commons/lib/prototypes/function.js
  var require_function = __commonJS((exports, module) => {
    "use strict";
    var copyPrototype = require_copy_prototype();
    module.exports = copyPrototype(Function.prototype);
  });

  // node_modules/@sinonjs/commons/lib/prototypes/map.js
  var require_map = __commonJS((exports, module) => {
    "use strict";
    var copyPrototype = require_copy_prototype();
    module.exports = copyPrototype(Map.prototype);
  });

  // node_modules/@sinonjs/commons/lib/prototypes/object.js
  var require_object = __commonJS((exports, module) => {
    "use strict";
    var copyPrototype = require_copy_prototype();
    module.exports = copyPrototype(Object.prototype);
  });

  // node_modules/@sinonjs/commons/lib/prototypes/set.js
  var require_set = __commonJS((exports, module) => {
    "use strict";
    var copyPrototype = require_copy_prototype();
    module.exports = copyPrototype(Set.prototype);
  });

  // node_modules/@sinonjs/commons/lib/prototypes/string.js
  var require_string = __commonJS((exports, module) => {
    "use strict";
    var copyPrototype = require_copy_prototype();
    module.exports = copyPrototype(String.prototype);
  });

  // node_modules/@sinonjs/commons/lib/prototypes/index.js
  var require_prototypes = __commonJS((exports, module) => {
    "use strict";
    module.exports = {
      array: require_array(),
      function: require_function(),
      map: require_map(),
      object: require_object(),
      set: require_set(),
      string: require_string()
    };
  });

  // node_modules/type-detect/type-detect.js
  var require_type_detect = __commonJS((exports, module) => {
    (function(global2, factory) {
      typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : global2.typeDetect = factory();
    })(exports, function() {
      "use strict";
      var promiseExists = typeof Promise === "function";
      var globalObject = typeof self === "object" ? self : global;
      var symbolExists = typeof Symbol !== "undefined";
      var mapExists = typeof Map !== "undefined";
      var setExists = typeof Set !== "undefined";
      var weakMapExists = typeof WeakMap !== "undefined";
      var weakSetExists = typeof WeakSet !== "undefined";
      var dataViewExists = typeof DataView !== "undefined";
      var symbolIteratorExists = symbolExists && typeof Symbol.iterator !== "undefined";
      var symbolToStringTagExists = symbolExists && typeof Symbol.toStringTag !== "undefined";
      var setEntriesExists = setExists && typeof Set.prototype.entries === "function";
      var mapEntriesExists = mapExists && typeof Map.prototype.entries === "function";
      var setIteratorPrototype = setEntriesExists && Object.getPrototypeOf(new Set().entries());
      var mapIteratorPrototype = mapEntriesExists && Object.getPrototypeOf(new Map().entries());
      var arrayIteratorExists = symbolIteratorExists && typeof Array.prototype[Symbol.iterator] === "function";
      var arrayIteratorPrototype = arrayIteratorExists && Object.getPrototypeOf([][Symbol.iterator]());
      var stringIteratorExists = symbolIteratorExists && typeof String.prototype[Symbol.iterator] === "function";
      var stringIteratorPrototype = stringIteratorExists && Object.getPrototypeOf(""[Symbol.iterator]());
      var toStringLeftSliceLength = 8;
      var toStringRightSliceLength = -1;
      function typeDetect(obj) {
        var typeofObj = typeof obj;
        if (typeofObj !== "object") {
          return typeofObj;
        }
        if (obj === null) {
          return "null";
        }
        if (obj === globalObject) {
          return "global";
        }
        if (Array.isArray(obj) && (symbolToStringTagExists === false || !(Symbol.toStringTag in obj))) {
          return "Array";
        }
        if (typeof window === "object" && window !== null) {
          if (typeof window.location === "object" && obj === window.location) {
            return "Location";
          }
          if (typeof window.document === "object" && obj === window.document) {
            return "Document";
          }
          if (typeof window.navigator === "object") {
            if (typeof window.navigator.mimeTypes === "object" && obj === window.navigator.mimeTypes) {
              return "MimeTypeArray";
            }
            if (typeof window.navigator.plugins === "object" && obj === window.navigator.plugins) {
              return "PluginArray";
            }
          }
          if ((typeof window.HTMLElement === "function" || typeof window.HTMLElement === "object") && obj instanceof window.HTMLElement) {
            if (obj.tagName === "BLOCKQUOTE") {
              return "HTMLQuoteElement";
            }
            if (obj.tagName === "TD") {
              return "HTMLTableDataCellElement";
            }
            if (obj.tagName === "TH") {
              return "HTMLTableHeaderCellElement";
            }
          }
        }
        var stringTag = symbolToStringTagExists && obj[Symbol.toStringTag];
        if (typeof stringTag === "string") {
          return stringTag;
        }
        var objPrototype = Object.getPrototypeOf(obj);
        if (objPrototype === RegExp.prototype) {
          return "RegExp";
        }
        if (objPrototype === Date.prototype) {
          return "Date";
        }
        if (promiseExists && objPrototype === Promise.prototype) {
          return "Promise";
        }
        if (setExists && objPrototype === Set.prototype) {
          return "Set";
        }
        if (mapExists && objPrototype === Map.prototype) {
          return "Map";
        }
        if (weakSetExists && objPrototype === WeakSet.prototype) {
          return "WeakSet";
        }
        if (weakMapExists && objPrototype === WeakMap.prototype) {
          return "WeakMap";
        }
        if (dataViewExists && objPrototype === DataView.prototype) {
          return "DataView";
        }
        if (mapExists && objPrototype === mapIteratorPrototype) {
          return "Map Iterator";
        }
        if (setExists && objPrototype === setIteratorPrototype) {
          return "Set Iterator";
        }
        if (arrayIteratorExists && objPrototype === arrayIteratorPrototype) {
          return "Array Iterator";
        }
        if (stringIteratorExists && objPrototype === stringIteratorPrototype) {
          return "String Iterator";
        }
        if (objPrototype === null) {
          return "Object";
        }
        return Object.prototype.toString.call(obj).slice(toStringLeftSliceLength, toStringRightSliceLength);
      }
      return typeDetect;
    });
  });

  // node_modules/@sinonjs/commons/lib/type-of.js
  var require_type_of = __commonJS((exports, module) => {
    "use strict";
    var type = require_type_detect();
    module.exports = function typeOf(value) {
      return type(value).toLowerCase();
    };
  });

  // node_modules/@sinonjs/commons/lib/value-to-string.js
  var require_value_to_string = __commonJS((exports, module) => {
    "use strict";
    function valueToString(value) {
      if (value && value.toString) {
        return value.toString();
      }
      return String(value);
    }
    module.exports = valueToString;
  });

  // node_modules/@sinonjs/commons/lib/index.js
  var require_lib = __commonJS((exports, module) => {
    "use strict";
    module.exports = {
      global: require_global(),
      calledInOrder: require_called_in_order(),
      className: require_class_name(),
      deprecated: require_deprecated(),
      every: require_every(),
      functionName: require_function_name(),
      orderByFirstCall: require_order_by_first_call(),
      prototypes: require_prototypes(),
      typeOf: require_type_of(),
      valueToString: require_value_to_string()
    };
  });

  // lib/assert-arg-num.js
  var require_assert_arg_num = __commonJS((exports, module) => {
    "use strict";
    function assertArgNum(fail, name, args, num) {
      if (args.length >= num) {
        return true;
      }
      fail(`[${name}] Expected to receive at least ${num} argument(s)`);
      return false;
    }
    module.exports = assertArgNum;
  });

  // node_modules/is-arguments/index.js
  var require_is_arguments = __commonJS((exports, module) => {
    "use strict";
    var hasToStringTag = typeof Symbol === "function" && typeof Symbol.toStringTag === "symbol";
    var toStr = Object.prototype.toString;
    var isStandardArguments = function isArguments(value) {
      if (hasToStringTag && value && typeof value === "object" && Symbol.toStringTag in value) {
        return false;
      }
      return toStr.call(value) === "[object Arguments]";
    };
    var isLegacyArguments = function isArguments(value) {
      if (isStandardArguments(value)) {
        return true;
      }
      return value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && toStr.call(value) !== "[object Array]" && toStr.call(value.callee) === "[object Function]";
    };
    var supportsStandardArguments = function() {
      return isStandardArguments(arguments);
    }();
    isStandardArguments.isLegacyArguments = isLegacyArguments;
    module.exports = supportsStandardArguments ? isStandardArguments : isLegacyArguments;
  });

  // node_modules/is-generator-function/index.js
  var require_is_generator_function = __commonJS((exports, module) => {
    "use strict";
    var toStr = Object.prototype.toString;
    var fnToStr = Function.prototype.toString;
    var isFnRegex = /^\s*(?:function)?\*/;
    var hasToStringTag = typeof Symbol === "function" && typeof Symbol.toStringTag === "symbol";
    var getProto = Object.getPrototypeOf;
    var getGeneratorFunc = function() {
      if (!hasToStringTag) {
        return false;
      }
      try {
        return Function("return function*() {}")();
      } catch (e) {
      }
    };
    var generatorFunc = getGeneratorFunc();
    var GeneratorFunction = generatorFunc ? getProto(generatorFunc) : {};
    module.exports = function isGeneratorFunction(fn) {
      if (typeof fn !== "function") {
        return false;
      }
      if (isFnRegex.test(fnToStr.call(fn))) {
        return true;
      }
      if (!hasToStringTag) {
        var str = toStr.call(fn);
        return str === "[object GeneratorFunction]";
      }
      return getProto(fn) === GeneratorFunction;
    };
  });

  // node_modules/foreach/index.js
  var require_foreach = __commonJS((exports, module) => {
    var hasOwn = Object.prototype.hasOwnProperty;
    var toString = Object.prototype.toString;
    module.exports = function forEach(obj, fn, ctx) {
      if (toString.call(fn) !== "[object Function]") {
        throw new TypeError("iterator must be a function");
      }
      var l = obj.length;
      if (l === +l) {
        for (var i = 0; i < l; i++) {
          fn.call(ctx, obj[i], i, obj);
        }
      } else {
        for (var k in obj) {
          if (hasOwn.call(obj, k)) {
            fn.call(ctx, obj[k], k, obj);
          }
        }
      }
    };
  });

  // node_modules/array-filter/index.js
  var require_array_filter = __commonJS((exports, module) => {
    module.exports = function(arr, fn, self2) {
      if (arr.filter)
        return arr.filter(fn, self2);
      if (arr === void 0 || arr === null)
        throw new TypeError();
      if (typeof fn != "function")
        throw new TypeError();
      var ret = [];
      for (var i = 0; i < arr.length; i++) {
        if (!hasOwn.call(arr, i))
          continue;
        var val = arr[i];
        if (fn.call(self2, val, i, arr))
          ret.push(val);
      }
      return ret;
    };
    var hasOwn = Object.prototype.hasOwnProperty;
  });

  // node_modules/available-typed-arrays/index.js
  var require_available_typed_arrays = __commonJS((exports, module) => {
    "use strict";
    var filter = require_array_filter();
    module.exports = function availableTypedArrays() {
      return filter([
        "BigInt64Array",
        "BigUint64Array",
        "Float32Array",
        "Float64Array",
        "Int16Array",
        "Int32Array",
        "Int8Array",
        "Uint16Array",
        "Uint32Array",
        "Uint8Array",
        "Uint8ClampedArray"
      ], function(typedArray) {
        return typeof global[typedArray] === "function";
      });
    };
  });

  // node_modules/has-symbols/shams.js
  var require_shams = __commonJS((exports, module) => {
    "use strict";
    module.exports = function hasSymbols() {
      if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
        return false;
      }
      if (typeof Symbol.iterator === "symbol") {
        return true;
      }
      var obj = {};
      var sym = Symbol("test");
      var symObj = Object(sym);
      if (typeof sym === "string") {
        return false;
      }
      if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
        return false;
      }
      if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
        return false;
      }
      var symVal = 42;
      obj[sym] = symVal;
      for (sym in obj) {
        return false;
      }
      if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
        return false;
      }
      if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
        return false;
      }
      var syms = Object.getOwnPropertySymbols(obj);
      if (syms.length !== 1 || syms[0] !== sym) {
        return false;
      }
      if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
        return false;
      }
      if (typeof Object.getOwnPropertyDescriptor === "function") {
        var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
        if (descriptor.value !== symVal || descriptor.enumerable !== true) {
          return false;
        }
      }
      return true;
    };
  });

  // node_modules/has-symbols/index.js
  var require_has_symbols = __commonJS((exports, module) => {
    "use strict";
    var origSymbol = global.Symbol;
    var hasSymbolSham = require_shams();
    module.exports = function hasNativeSymbols() {
      if (typeof origSymbol !== "function") {
        return false;
      }
      if (typeof Symbol !== "function") {
        return false;
      }
      if (typeof origSymbol("foo") !== "symbol") {
        return false;
      }
      if (typeof Symbol("bar") !== "symbol") {
        return false;
      }
      return hasSymbolSham();
    };
  });

  // node_modules/function-bind/implementation.js
  var require_implementation = __commonJS((exports, module) => {
    "use strict";
    var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
    var slice = Array.prototype.slice;
    var toStr = Object.prototype.toString;
    var funcType = "[object Function]";
    module.exports = function bind(that) {
      var target = this;
      if (typeof target !== "function" || toStr.call(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
      }
      var args = slice.call(arguments, 1);
      var bound;
      var binder = function() {
        if (this instanceof bound) {
          var result = target.apply(this, args.concat(slice.call(arguments)));
          if (Object(result) === result) {
            return result;
          }
          return this;
        } else {
          return target.apply(that, args.concat(slice.call(arguments)));
        }
      };
      var boundLength = Math.max(0, target.length - args.length);
      var boundArgs = [];
      for (var i = 0; i < boundLength; i++) {
        boundArgs.push("$" + i);
      }
      bound = Function("binder", "return function (" + boundArgs.join(",") + "){ return binder.apply(this,arguments); }")(binder);
      if (target.prototype) {
        var Empty = function Empty2() {
        };
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
      }
      return bound;
    };
  });

  // node_modules/function-bind/index.js
  var require_function_bind = __commonJS((exports, module) => {
    "use strict";
    var implementation = require_implementation();
    module.exports = Function.prototype.bind || implementation;
  });

  // node_modules/es-abstract/GetIntrinsic.js
  var require_GetIntrinsic = __commonJS((exports, module) => {
    "use strict";
    var undefined2;
    var $TypeError = TypeError;
    var $gOPD = Object.getOwnPropertyDescriptor;
    if ($gOPD) {
      try {
        $gOPD({}, "");
      } catch (e) {
        $gOPD = null;
      }
    }
    var throwTypeError = function() {
      throw new $TypeError();
    };
    var ThrowTypeError = $gOPD ? function() {
      try {
        arguments.callee;
        return throwTypeError;
      } catch (calleeThrows) {
        try {
          return $gOPD(arguments, "callee").get;
        } catch (gOPDthrows) {
          return throwTypeError;
        }
      }
    }() : throwTypeError;
    var hasSymbols = require_has_symbols()();
    var getProto = Object.getPrototypeOf || function(x) {
      return x.__proto__;
    };
    var generator;
    var generatorFunction = generator ? getProto(generator) : undefined2;
    var asyncFn;
    var asyncFunction = asyncFn ? asyncFn.constructor : undefined2;
    var asyncGen;
    var asyncGenFunction = asyncGen ? getProto(asyncGen) : undefined2;
    var asyncGenIterator = asyncGen ? asyncGen() : undefined2;
    var TypedArray = typeof Uint8Array === "undefined" ? undefined2 : getProto(Uint8Array);
    var INTRINSICS = {
      "%Array%": Array,
      "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined2 : ArrayBuffer,
      "%ArrayBufferPrototype%": typeof ArrayBuffer === "undefined" ? undefined2 : ArrayBuffer.prototype,
      "%ArrayIteratorPrototype%": hasSymbols ? getProto([][Symbol.iterator]()) : undefined2,
      "%ArrayPrototype%": Array.prototype,
      "%ArrayProto_entries%": Array.prototype.entries,
      "%ArrayProto_forEach%": Array.prototype.forEach,
      "%ArrayProto_keys%": Array.prototype.keys,
      "%ArrayProto_values%": Array.prototype.values,
      "%AsyncFromSyncIteratorPrototype%": undefined2,
      "%AsyncFunction%": asyncFunction,
      "%AsyncFunctionPrototype%": asyncFunction ? asyncFunction.prototype : undefined2,
      "%AsyncGenerator%": asyncGen ? getProto(asyncGenIterator) : undefined2,
      "%AsyncGeneratorFunction%": asyncGenFunction,
      "%AsyncGeneratorPrototype%": asyncGenFunction ? asyncGenFunction.prototype : undefined2,
      "%AsyncIteratorPrototype%": asyncGenIterator && hasSymbols && Symbol.asyncIterator ? asyncGenIterator[Symbol.asyncIterator]() : undefined2,
      "%Atomics%": typeof Atomics === "undefined" ? undefined2 : Atomics,
      "%Boolean%": Boolean,
      "%BooleanPrototype%": Boolean.prototype,
      "%DataView%": typeof DataView === "undefined" ? undefined2 : DataView,
      "%DataViewPrototype%": typeof DataView === "undefined" ? undefined2 : DataView.prototype,
      "%Date%": Date,
      "%DatePrototype%": Date.prototype,
      "%decodeURI%": decodeURI,
      "%decodeURIComponent%": decodeURIComponent,
      "%encodeURI%": encodeURI,
      "%encodeURIComponent%": encodeURIComponent,
      "%Error%": Error,
      "%ErrorPrototype%": Error.prototype,
      "%eval%": eval,
      "%EvalError%": EvalError,
      "%EvalErrorPrototype%": EvalError.prototype,
      "%Float32Array%": typeof Float32Array === "undefined" ? undefined2 : Float32Array,
      "%Float32ArrayPrototype%": typeof Float32Array === "undefined" ? undefined2 : Float32Array.prototype,
      "%Float64Array%": typeof Float64Array === "undefined" ? undefined2 : Float64Array,
      "%Float64ArrayPrototype%": typeof Float64Array === "undefined" ? undefined2 : Float64Array.prototype,
      "%Function%": Function,
      "%FunctionPrototype%": Function.prototype,
      "%Generator%": generator ? getProto(generator()) : undefined2,
      "%GeneratorFunction%": generatorFunction,
      "%GeneratorPrototype%": generatorFunction ? generatorFunction.prototype : undefined2,
      "%Int8Array%": typeof Int8Array === "undefined" ? undefined2 : Int8Array,
      "%Int8ArrayPrototype%": typeof Int8Array === "undefined" ? undefined2 : Int8Array.prototype,
      "%Int16Array%": typeof Int16Array === "undefined" ? undefined2 : Int16Array,
      "%Int16ArrayPrototype%": typeof Int16Array === "undefined" ? undefined2 : Int8Array.prototype,
      "%Int32Array%": typeof Int32Array === "undefined" ? undefined2 : Int32Array,
      "%Int32ArrayPrototype%": typeof Int32Array === "undefined" ? undefined2 : Int32Array.prototype,
      "%isFinite%": isFinite,
      "%isNaN%": isNaN,
      "%IteratorPrototype%": hasSymbols ? getProto(getProto([][Symbol.iterator]())) : undefined2,
      "%JSON%": typeof JSON === "object" ? JSON : undefined2,
      "%JSONParse%": typeof JSON === "object" ? JSON.parse : undefined2,
      "%Map%": typeof Map === "undefined" ? undefined2 : Map,
      "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols ? undefined2 : getProto(new Map()[Symbol.iterator]()),
      "%MapPrototype%": typeof Map === "undefined" ? undefined2 : Map.prototype,
      "%Math%": Math,
      "%Number%": Number,
      "%NumberPrototype%": Number.prototype,
      "%Object%": Object,
      "%ObjectPrototype%": Object.prototype,
      "%ObjProto_toString%": Object.prototype.toString,
      "%ObjProto_valueOf%": Object.prototype.valueOf,
      "%parseFloat%": parseFloat,
      "%parseInt%": parseInt,
      "%Promise%": typeof Promise === "undefined" ? undefined2 : Promise,
      "%PromisePrototype%": typeof Promise === "undefined" ? undefined2 : Promise.prototype,
      "%PromiseProto_then%": typeof Promise === "undefined" ? undefined2 : Promise.prototype.then,
      "%Promise_all%": typeof Promise === "undefined" ? undefined2 : Promise.all,
      "%Promise_reject%": typeof Promise === "undefined" ? undefined2 : Promise.reject,
      "%Promise_resolve%": typeof Promise === "undefined" ? undefined2 : Promise.resolve,
      "%Proxy%": typeof Proxy === "undefined" ? undefined2 : Proxy,
      "%RangeError%": RangeError,
      "%RangeErrorPrototype%": RangeError.prototype,
      "%ReferenceError%": ReferenceError,
      "%ReferenceErrorPrototype%": ReferenceError.prototype,
      "%Reflect%": typeof Reflect === "undefined" ? undefined2 : Reflect,
      "%RegExp%": RegExp,
      "%RegExpPrototype%": RegExp.prototype,
      "%Set%": typeof Set === "undefined" ? undefined2 : Set,
      "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols ? undefined2 : getProto(new Set()[Symbol.iterator]()),
      "%SetPrototype%": typeof Set === "undefined" ? undefined2 : Set.prototype,
      "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined2 : SharedArrayBuffer,
      "%SharedArrayBufferPrototype%": typeof SharedArrayBuffer === "undefined" ? undefined2 : SharedArrayBuffer.prototype,
      "%String%": String,
      "%StringIteratorPrototype%": hasSymbols ? getProto(""[Symbol.iterator]()) : undefined2,
      "%StringPrototype%": String.prototype,
      "%Symbol%": hasSymbols ? Symbol : undefined2,
      "%SymbolPrototype%": hasSymbols ? Symbol.prototype : undefined2,
      "%SyntaxError%": SyntaxError,
      "%SyntaxErrorPrototype%": SyntaxError.prototype,
      "%ThrowTypeError%": ThrowTypeError,
      "%TypedArray%": TypedArray,
      "%TypedArrayPrototype%": TypedArray ? TypedArray.prototype : undefined2,
      "%TypeError%": $TypeError,
      "%TypeErrorPrototype%": $TypeError.prototype,
      "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined2 : Uint8Array,
      "%Uint8ArrayPrototype%": typeof Uint8Array === "undefined" ? undefined2 : Uint8Array.prototype,
      "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined2 : Uint8ClampedArray,
      "%Uint8ClampedArrayPrototype%": typeof Uint8ClampedArray === "undefined" ? undefined2 : Uint8ClampedArray.prototype,
      "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined2 : Uint16Array,
      "%Uint16ArrayPrototype%": typeof Uint16Array === "undefined" ? undefined2 : Uint16Array.prototype,
      "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined2 : Uint32Array,
      "%Uint32ArrayPrototype%": typeof Uint32Array === "undefined" ? undefined2 : Uint32Array.prototype,
      "%URIError%": URIError,
      "%URIErrorPrototype%": URIError.prototype,
      "%WeakMap%": typeof WeakMap === "undefined" ? undefined2 : WeakMap,
      "%WeakMapPrototype%": typeof WeakMap === "undefined" ? undefined2 : WeakMap.prototype,
      "%WeakSet%": typeof WeakSet === "undefined" ? undefined2 : WeakSet,
      "%WeakSetPrototype%": typeof WeakSet === "undefined" ? undefined2 : WeakSet.prototype
    };
    var bind = require_function_bind();
    var $replace = bind.call(Function.call, String.prototype.replace);
    var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
    var reEscapeChar = /\\(\\)?/g;
    var stringToPath = function stringToPath2(string) {
      var result = [];
      $replace(string, rePropName, function(match, number, quote, subString) {
        result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number || match;
      });
      return result;
    };
    var getBaseIntrinsic = function getBaseIntrinsic2(name, allowMissing) {
      if (!(name in INTRINSICS)) {
        throw new SyntaxError("intrinsic " + name + " does not exist!");
      }
      if (typeof INTRINSICS[name] === "undefined" && !allowMissing) {
        throw new $TypeError("intrinsic " + name + " exists, but is not available. Please file an issue!");
      }
      return INTRINSICS[name];
    };
    module.exports = function GetIntrinsic(name, allowMissing) {
      if (typeof name !== "string" || name.length === 0) {
        throw new TypeError("intrinsic name must be a non-empty string");
      }
      if (arguments.length > 1 && typeof allowMissing !== "boolean") {
        throw new TypeError('"allowMissing" argument must be a boolean');
      }
      var parts = stringToPath(name);
      var value = getBaseIntrinsic("%" + (parts.length > 0 ? parts[0] : "") + "%", allowMissing);
      for (var i = 1; i < parts.length; i += 1) {
        if (value != null) {
          if ($gOPD && i + 1 >= parts.length) {
            var desc = $gOPD(value, parts[i]);
            if (!allowMissing && !(parts[i] in value)) {
              throw new $TypeError("base intrinsic for " + name + " exists, but the property is not available.");
            }
            value = desc ? desc.get || desc.value : value[parts[i]];
          } else {
            value = value[parts[i]];
          }
        }
      }
      return value;
    };
  });

  // node_modules/es-abstract/helpers/callBind.js
  var require_callBind = __commonJS((exports, module) => {
    "use strict";
    var bind = require_function_bind();
    var GetIntrinsic = require_GetIntrinsic();
    var $apply = GetIntrinsic("%Function.prototype.apply%");
    var $call = GetIntrinsic("%Function.prototype.call%");
    var $reflectApply = GetIntrinsic("%Reflect.apply%", true) || bind.call($call, $apply);
    module.exports = function callBind() {
      return $reflectApply(bind, $call, arguments);
    };
    module.exports.apply = function applyBind() {
      return $reflectApply(bind, $apply, arguments);
    };
  });

  // node_modules/es-abstract/helpers/callBound.js
  var require_callBound = __commonJS((exports, module) => {
    "use strict";
    var GetIntrinsic = require_GetIntrinsic();
    var callBind = require_callBind();
    var $indexOf = callBind(GetIntrinsic("String.prototype.indexOf"));
    module.exports = function callBoundIntrinsic(name, allowMissing) {
      var intrinsic = GetIntrinsic(name, !!allowMissing);
      if (typeof intrinsic === "function" && $indexOf(name, ".prototype.")) {
        return callBind(intrinsic);
      }
      return intrinsic;
    };
  });

  // node_modules/es-abstract/helpers/getOwnPropertyDescriptor.js
  var require_getOwnPropertyDescriptor = __commonJS((exports, module) => {
    "use strict";
    var GetIntrinsic = require_GetIntrinsic();
    var $gOPD = GetIntrinsic("%Object.getOwnPropertyDescriptor%");
    if ($gOPD) {
      try {
        $gOPD([], "length");
      } catch (e) {
        $gOPD = null;
      }
    }
    module.exports = $gOPD;
  });

  // node_modules/is-typed-array/index.js
  var require_is_typed_array = __commonJS((exports, module) => {
    "use strict";
    var forEach = require_foreach();
    var availableTypedArrays = require_available_typed_arrays();
    var callBound = require_callBound();
    var $toString = callBound("Object.prototype.toString");
    var hasSymbols = require_has_symbols()();
    var hasToStringTag = hasSymbols && typeof Symbol.toStringTag === "symbol";
    var typedArrays = availableTypedArrays();
    var $indexOf = callBound("Array.prototype.indexOf", true) || function indexOf(array, value) {
      for (var i = 0; i < array.length; i += 1) {
        if (array[i] === value) {
          return i;
        }
      }
      return -1;
    };
    var $slice = callBound("String.prototype.slice");
    var toStrTags = {};
    var gOPD = require_getOwnPropertyDescriptor();
    var getPrototypeOf = Object.getPrototypeOf;
    if (hasToStringTag && gOPD && getPrototypeOf) {
      forEach(typedArrays, function(typedArray) {
        var arr = new global[typedArray]();
        if (!(Symbol.toStringTag in arr)) {
          throw new EvalError("this engine has support for Symbol.toStringTag, but " + typedArray + " does not have the property! Please report this.");
        }
        var proto = getPrototypeOf(arr);
        var descriptor = gOPD(proto, Symbol.toStringTag);
        if (!descriptor) {
          var superProto = getPrototypeOf(proto);
          descriptor = gOPD(superProto, Symbol.toStringTag);
        }
        toStrTags[typedArray] = descriptor.get;
      });
    }
    var tryTypedArrays = function tryAllTypedArrays(value) {
      var anyTrue = false;
      forEach(toStrTags, function(getter, typedArray) {
        if (!anyTrue) {
          try {
            anyTrue = getter.call(value) === typedArray;
          } catch (e) {
          }
        }
      });
      return anyTrue;
    };
    module.exports = function isTypedArray(value) {
      if (!value || typeof value !== "object") {
        return false;
      }
      if (!hasToStringTag) {
        var tag = $slice($toString(value), 8, -1);
        return $indexOf(typedArrays, tag) > -1;
      }
      if (!gOPD) {
        return false;
      }
      return tryTypedArrays(value);
    };
  });

  // node_modules/which-typed-array/index.js
  var require_which_typed_array = __commonJS((exports, module) => {
    "use strict";
    var forEach = require_foreach();
    var availableTypedArrays = require_available_typed_arrays();
    var callBound = require_callBound();
    var $toString = callBound("Object.prototype.toString");
    var hasSymbols = require_has_symbols()();
    var hasToStringTag = hasSymbols && typeof Symbol.toStringTag === "symbol";
    var typedArrays = availableTypedArrays();
    var $slice = callBound("String.prototype.slice");
    var toStrTags = {};
    var gOPD = require_getOwnPropertyDescriptor();
    var getPrototypeOf = Object.getPrototypeOf;
    if (hasToStringTag && gOPD && getPrototypeOf) {
      forEach(typedArrays, function(typedArray) {
        if (typeof global[typedArray] === "function") {
          var arr = new global[typedArray]();
          if (!(Symbol.toStringTag in arr)) {
            throw new EvalError("this engine has support for Symbol.toStringTag, but " + typedArray + " does not have the property! Please report this.");
          }
          var proto = getPrototypeOf(arr);
          var descriptor = gOPD(proto, Symbol.toStringTag);
          if (!descriptor) {
            var superProto = getPrototypeOf(proto);
            descriptor = gOPD(superProto, Symbol.toStringTag);
          }
          toStrTags[typedArray] = descriptor.get;
        }
      });
    }
    var tryTypedArrays = function tryAllTypedArrays(value) {
      var foundName = false;
      forEach(toStrTags, function(getter, typedArray) {
        if (!foundName) {
          try {
            var name = getter.call(value);
            if (name === typedArray) {
              foundName = name;
            }
          } catch (e) {
          }
        }
      });
      return foundName;
    };
    var isTypedArray = require_is_typed_array();
    module.exports = function whichTypedArray(value) {
      if (!isTypedArray(value)) {
        return false;
      }
      if (!hasToStringTag) {
        return $slice($toString(value), 8, -1);
      }
      return tryTypedArrays(value);
    };
  });

  // node_modules/util/support/types.js
  var require_types = __commonJS((exports) => {
    "use strict";
    var isArgumentsObject = require_is_arguments();
    var isGeneratorFunction = require_is_generator_function();
    var whichTypedArray = require_which_typed_array();
    var isTypedArray = require_is_typed_array();
    function uncurryThis(f) {
      return f.call.bind(f);
    }
    var BigIntSupported = typeof BigInt !== "undefined";
    var SymbolSupported = typeof Symbol !== "undefined";
    var ObjectToString = uncurryThis(Object.prototype.toString);
    var numberValue = uncurryThis(Number.prototype.valueOf);
    var stringValue = uncurryThis(String.prototype.valueOf);
    var booleanValue = uncurryThis(Boolean.prototype.valueOf);
    if (BigIntSupported) {
      var bigIntValue = uncurryThis(BigInt.prototype.valueOf);
    }
    if (SymbolSupported) {
      var symbolValue = uncurryThis(Symbol.prototype.valueOf);
    }
    function checkBoxedPrimitive(value, prototypeValueOf) {
      if (typeof value !== "object") {
        return false;
      }
      try {
        prototypeValueOf(value);
        return true;
      } catch (e) {
        return false;
      }
    }
    exports.isArgumentsObject = isArgumentsObject;
    exports.isGeneratorFunction = isGeneratorFunction;
    exports.isTypedArray = isTypedArray;
    function isPromise(input) {
      return typeof Promise !== "undefined" && input instanceof Promise || input !== null && typeof input === "object" && typeof input.then === "function" && typeof input.catch === "function";
    }
    exports.isPromise = isPromise;
    function isArrayBufferView(value) {
      if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
        return ArrayBuffer.isView(value);
      }
      return isTypedArray(value) || isDataView(value);
    }
    exports.isArrayBufferView = isArrayBufferView;
    function isUint8Array(value) {
      return whichTypedArray(value) === "Uint8Array";
    }
    exports.isUint8Array = isUint8Array;
    function isUint8ClampedArray(value) {
      return whichTypedArray(value) === "Uint8ClampedArray";
    }
    exports.isUint8ClampedArray = isUint8ClampedArray;
    function isUint16Array(value) {
      return whichTypedArray(value) === "Uint16Array";
    }
    exports.isUint16Array = isUint16Array;
    function isUint32Array(value) {
      return whichTypedArray(value) === "Uint32Array";
    }
    exports.isUint32Array = isUint32Array;
    function isInt8Array(value) {
      return whichTypedArray(value) === "Int8Array";
    }
    exports.isInt8Array = isInt8Array;
    function isInt16Array(value) {
      return whichTypedArray(value) === "Int16Array";
    }
    exports.isInt16Array = isInt16Array;
    function isInt32Array(value) {
      return whichTypedArray(value) === "Int32Array";
    }
    exports.isInt32Array = isInt32Array;
    function isFloat32Array(value) {
      return whichTypedArray(value) === "Float32Array";
    }
    exports.isFloat32Array = isFloat32Array;
    function isFloat64Array(value) {
      return whichTypedArray(value) === "Float64Array";
    }
    exports.isFloat64Array = isFloat64Array;
    function isBigInt64Array(value) {
      return whichTypedArray(value) === "BigInt64Array";
    }
    exports.isBigInt64Array = isBigInt64Array;
    function isBigUint64Array(value) {
      return whichTypedArray(value) === "BigUint64Array";
    }
    exports.isBigUint64Array = isBigUint64Array;
    function isMapToString(value) {
      return ObjectToString(value) === "[object Map]";
    }
    isMapToString.working = typeof Map !== "undefined" && isMapToString(new Map());
    function isMap(value) {
      if (typeof Map === "undefined") {
        return false;
      }
      return isMapToString.working ? isMapToString(value) : value instanceof Map;
    }
    exports.isMap = isMap;
    function isSetToString(value) {
      return ObjectToString(value) === "[object Set]";
    }
    isSetToString.working = typeof Set !== "undefined" && isSetToString(new Set());
    function isSet(value) {
      if (typeof Set === "undefined") {
        return false;
      }
      return isSetToString.working ? isSetToString(value) : value instanceof Set;
    }
    exports.isSet = isSet;
    function isWeakMapToString(value) {
      return ObjectToString(value) === "[object WeakMap]";
    }
    isWeakMapToString.working = typeof WeakMap !== "undefined" && isWeakMapToString(new WeakMap());
    function isWeakMap(value) {
      if (typeof WeakMap === "undefined") {
        return false;
      }
      return isWeakMapToString.working ? isWeakMapToString(value) : value instanceof WeakMap;
    }
    exports.isWeakMap = isWeakMap;
    function isWeakSetToString(value) {
      return ObjectToString(value) === "[object WeakSet]";
    }
    isWeakSetToString.working = typeof WeakSet !== "undefined" && isWeakSetToString(new WeakSet());
    function isWeakSet(value) {
      return isWeakSetToString(value);
    }
    exports.isWeakSet = isWeakSet;
    function isArrayBufferToString(value) {
      return ObjectToString(value) === "[object ArrayBuffer]";
    }
    isArrayBufferToString.working = typeof ArrayBuffer !== "undefined" && isArrayBufferToString(new ArrayBuffer());
    function isArrayBuffer(value) {
      if (typeof ArrayBuffer === "undefined") {
        return false;
      }
      return isArrayBufferToString.working ? isArrayBufferToString(value) : value instanceof ArrayBuffer;
    }
    exports.isArrayBuffer = isArrayBuffer;
    function isDataViewToString(value) {
      return ObjectToString(value) === "[object DataView]";
    }
    isDataViewToString.working = typeof ArrayBuffer !== "undefined" && typeof DataView !== "undefined" && isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1));
    function isDataView(value) {
      if (typeof DataView === "undefined") {
        return false;
      }
      return isDataViewToString.working ? isDataViewToString(value) : value instanceof DataView;
    }
    exports.isDataView = isDataView;
    function isSharedArrayBufferToString(value) {
      return ObjectToString(value) === "[object SharedArrayBuffer]";
    }
    isSharedArrayBufferToString.working = typeof SharedArrayBuffer !== "undefined" && isSharedArrayBufferToString(new SharedArrayBuffer());
    function isSharedArrayBuffer(value) {
      if (typeof SharedArrayBuffer === "undefined") {
        return false;
      }
      return isSharedArrayBufferToString.working ? isSharedArrayBufferToString(value) : value instanceof SharedArrayBuffer;
    }
    exports.isSharedArrayBuffer = isSharedArrayBuffer;
    function isAsyncFunction(value) {
      return ObjectToString(value) === "[object AsyncFunction]";
    }
    exports.isAsyncFunction = isAsyncFunction;
    function isMapIterator(value) {
      return ObjectToString(value) === "[object Map Iterator]";
    }
    exports.isMapIterator = isMapIterator;
    function isSetIterator(value) {
      return ObjectToString(value) === "[object Set Iterator]";
    }
    exports.isSetIterator = isSetIterator;
    function isGeneratorObject(value) {
      return ObjectToString(value) === "[object Generator]";
    }
    exports.isGeneratorObject = isGeneratorObject;
    function isWebAssemblyCompiledModule(value) {
      return ObjectToString(value) === "[object WebAssembly.Module]";
    }
    exports.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule;
    function isNumberObject(value) {
      return checkBoxedPrimitive(value, numberValue);
    }
    exports.isNumberObject = isNumberObject;
    function isStringObject(value) {
      return checkBoxedPrimitive(value, stringValue);
    }
    exports.isStringObject = isStringObject;
    function isBooleanObject(value) {
      return checkBoxedPrimitive(value, booleanValue);
    }
    exports.isBooleanObject = isBooleanObject;
    function isBigIntObject(value) {
      return BigIntSupported && checkBoxedPrimitive(value, bigIntValue);
    }
    exports.isBigIntObject = isBigIntObject;
    function isSymbolObject(value) {
      return SymbolSupported && checkBoxedPrimitive(value, symbolValue);
    }
    exports.isSymbolObject = isSymbolObject;
    function isBoxedPrimitive(value) {
      return isNumberObject(value) || isStringObject(value) || isBooleanObject(value) || isBigIntObject(value) || isSymbolObject(value);
    }
    exports.isBoxedPrimitive = isBoxedPrimitive;
    function isAnyArrayBuffer(value) {
      return typeof Uint8Array !== "undefined" && (isArrayBuffer(value) || isSharedArrayBuffer(value));
    }
    exports.isAnyArrayBuffer = isAnyArrayBuffer;
    ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(method) {
      Object.defineProperty(exports, method, {
        enumerable: false,
        value: function() {
          throw new Error(method + " is not supported in userland");
        }
      });
    });
  });

  // node_modules/util/support/isBufferBrowser.js
  var require_isBufferBrowser = __commonJS((exports, module) => {
    module.exports = function isBuffer(arg) {
      return arg && typeof arg === "object" && typeof arg.copy === "function" && typeof arg.fill === "function" && typeof arg.readUInt8 === "function";
    };
  });

  // node_modules/inherits/inherits_browser.js
  var require_inherits_browser = __commonJS((exports, module) => {
    if (typeof Object.create === "function") {
      module.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      };
    } else {
      module.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
      };
    }
  });

  // node_modules/util/util.js
  var require_util = __commonJS((exports) => {
    var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors2(obj) {
      var keys = Object.keys(obj);
      var descriptors = {};
      for (var i = 0; i < keys.length; i++) {
        descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);
      }
      return descriptors;
    };
    var formatRegExp = /%[sdj%]/g;
    exports.format = function(f) {
      if (!isString(f)) {
        var objects = [];
        for (var i = 0; i < arguments.length; i++) {
          objects.push(inspect(arguments[i]));
        }
        return objects.join(" ");
      }
      var i = 1;
      var args = arguments;
      var len = args.length;
      var str = String(f).replace(formatRegExp, function(x2) {
        if (x2 === "%%")
          return "%";
        if (i >= len)
          return x2;
        switch (x2) {
          case "%s":
            return String(args[i++]);
          case "%d":
            return Number(args[i++]);
          case "%j":
            try {
              return JSON.stringify(args[i++]);
            } catch (_) {
              return "[Circular]";
            }
          default:
            return x2;
        }
      });
      for (var x = args[i]; i < len; x = args[++i]) {
        if (isNull(x) || !isObject(x)) {
          str += " " + x;
        } else {
          str += " " + inspect(x);
        }
      }
      return str;
    };
    exports.deprecate = function(fn, msg) {
      if (typeof process !== "undefined" && process.noDeprecation === true) {
        return fn;
      }
      if (typeof process === "undefined") {
        return function() {
          return exports.deprecate(fn, msg).apply(this, arguments);
        };
      }
      var warned = false;
      function deprecated() {
        if (!warned) {
          if (process.throwDeprecation) {
            throw new Error(msg);
          } else if (process.traceDeprecation) {
            console.trace(msg);
          } else {
            console.error(msg);
          }
          warned = true;
        }
        return fn.apply(this, arguments);
      }
      return deprecated;
    };
    var debugs = {};
    var debugEnvRegex = /^$/;
    if (process.env.NODE_DEBUG) {
      var debugEnv = process.env.NODE_DEBUG;
      debugEnv = debugEnv.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase();
      debugEnvRegex = new RegExp("^" + debugEnv + "$", "i");
    }
    exports.debuglog = function(set) {
      set = set.toUpperCase();
      if (!debugs[set]) {
        if (debugEnvRegex.test(set)) {
          var pid = process.pid;
          debugs[set] = function() {
            var msg = exports.format.apply(exports, arguments);
            console.error("%s %d: %s", set, pid, msg);
          };
        } else {
          debugs[set] = function() {
          };
        }
      }
      return debugs[set];
    };
    function inspect(obj, opts) {
      var ctx = {
        seen: [],
        stylize: stylizeNoColor
      };
      if (arguments.length >= 3)
        ctx.depth = arguments[2];
      if (arguments.length >= 4)
        ctx.colors = arguments[3];
      if (isBoolean(opts)) {
        ctx.showHidden = opts;
      } else if (opts) {
        exports._extend(ctx, opts);
      }
      if (isUndefined(ctx.showHidden))
        ctx.showHidden = false;
      if (isUndefined(ctx.depth))
        ctx.depth = 2;
      if (isUndefined(ctx.colors))
        ctx.colors = false;
      if (isUndefined(ctx.customInspect))
        ctx.customInspect = true;
      if (ctx.colors)
        ctx.stylize = stylizeWithColor;
      return formatValue(ctx, obj, ctx.depth);
    }
    exports.inspect = inspect;
    inspect.colors = {
      bold: [1, 22],
      italic: [3, 23],
      underline: [4, 24],
      inverse: [7, 27],
      white: [37, 39],
      grey: [90, 39],
      black: [30, 39],
      blue: [34, 39],
      cyan: [36, 39],
      green: [32, 39],
      magenta: [35, 39],
      red: [31, 39],
      yellow: [33, 39]
    };
    inspect.styles = {
      special: "cyan",
      number: "yellow",
      boolean: "yellow",
      undefined: "grey",
      null: "bold",
      string: "green",
      date: "magenta",
      regexp: "red"
    };
    function stylizeWithColor(str, styleType) {
      var style = inspect.styles[styleType];
      if (style) {
        return "[" + inspect.colors[style][0] + "m" + str + "[" + inspect.colors[style][1] + "m";
      } else {
        return str;
      }
    }
    function stylizeNoColor(str, styleType) {
      return str;
    }
    function arrayToHash(array) {
      var hash = {};
      array.forEach(function(val, idx) {
        hash[val] = true;
      });
      return hash;
    }
    function formatValue(ctx, value, recurseTimes) {
      if (ctx.customInspect && value && isFunction(value.inspect) && value.inspect !== exports.inspect && !(value.constructor && value.constructor.prototype === value)) {
        var ret = value.inspect(recurseTimes, ctx);
        if (!isString(ret)) {
          ret = formatValue(ctx, ret, recurseTimes);
        }
        return ret;
      }
      var primitive = formatPrimitive(ctx, value);
      if (primitive) {
        return primitive;
      }
      var keys = Object.keys(value);
      var visibleKeys = arrayToHash(keys);
      if (ctx.showHidden) {
        keys = Object.getOwnPropertyNames(value);
      }
      if (isError(value) && (keys.indexOf("message") >= 0 || keys.indexOf("description") >= 0)) {
        return formatError(value);
      }
      if (keys.length === 0) {
        if (isFunction(value)) {
          var name = value.name ? ": " + value.name : "";
          return ctx.stylize("[Function" + name + "]", "special");
        }
        if (isRegExp(value)) {
          return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
        }
        if (isDate(value)) {
          return ctx.stylize(Date.prototype.toString.call(value), "date");
        }
        if (isError(value)) {
          return formatError(value);
        }
      }
      var base = "", array = false, braces = ["{", "}"];
      if (isArray(value)) {
        array = true;
        braces = ["[", "]"];
      }
      if (isFunction(value)) {
        var n = value.name ? ": " + value.name : "";
        base = " [Function" + n + "]";
      }
      if (isRegExp(value)) {
        base = " " + RegExp.prototype.toString.call(value);
      }
      if (isDate(value)) {
        base = " " + Date.prototype.toUTCString.call(value);
      }
      if (isError(value)) {
        base = " " + formatError(value);
      }
      if (keys.length === 0 && (!array || value.length == 0)) {
        return braces[0] + base + braces[1];
      }
      if (recurseTimes < 0) {
        if (isRegExp(value)) {
          return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
        } else {
          return ctx.stylize("[Object]", "special");
        }
      }
      ctx.seen.push(value);
      var output;
      if (array) {
        output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
      } else {
        output = keys.map(function(key) {
          return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
        });
      }
      ctx.seen.pop();
      return reduceToSingleString(output, base, braces);
    }
    function formatPrimitive(ctx, value) {
      if (isUndefined(value))
        return ctx.stylize("undefined", "undefined");
      if (isString(value)) {
        var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
        return ctx.stylize(simple, "string");
      }
      if (isNumber(value))
        return ctx.stylize("" + value, "number");
      if (isBoolean(value))
        return ctx.stylize("" + value, "boolean");
      if (isNull(value))
        return ctx.stylize("null", "null");
    }
    function formatError(value) {
      return "[" + Error.prototype.toString.call(value) + "]";
    }
    function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
      var output = [];
      for (var i = 0, l = value.length; i < l; ++i) {
        if (hasOwnProperty2(value, String(i))) {
          output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));
        } else {
          output.push("");
        }
      }
      keys.forEach(function(key) {
        if (!key.match(/^\d+$/)) {
          output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
        }
      });
      return output;
    }
    function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
      var name, str, desc;
      desc = Object.getOwnPropertyDescriptor(value, key) || {value: value[key]};
      if (desc.get) {
        if (desc.set) {
          str = ctx.stylize("[Getter/Setter]", "special");
        } else {
          str = ctx.stylize("[Getter]", "special");
        }
      } else {
        if (desc.set) {
          str = ctx.stylize("[Setter]", "special");
        }
      }
      if (!hasOwnProperty2(visibleKeys, key)) {
        name = "[" + key + "]";
      }
      if (!str) {
        if (ctx.seen.indexOf(desc.value) < 0) {
          if (isNull(recurseTimes)) {
            str = formatValue(ctx, desc.value, null);
          } else {
            str = formatValue(ctx, desc.value, recurseTimes - 1);
          }
          if (str.indexOf("\n") > -1) {
            if (array) {
              str = str.split("\n").map(function(line) {
                return "  " + line;
              }).join("\n").substr(2);
            } else {
              str = "\n" + str.split("\n").map(function(line) {
                return "   " + line;
              }).join("\n");
            }
          }
        } else {
          str = ctx.stylize("[Circular]", "special");
        }
      }
      if (isUndefined(name)) {
        if (array && key.match(/^\d+$/)) {
          return str;
        }
        name = JSON.stringify("" + key);
        if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
          name = name.substr(1, name.length - 2);
          name = ctx.stylize(name, "name");
        } else {
          name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
          name = ctx.stylize(name, "string");
        }
      }
      return name + ": " + str;
    }
    function reduceToSingleString(output, base, braces) {
      var numLinesEst = 0;
      var length = output.reduce(function(prev, cur) {
        numLinesEst++;
        if (cur.indexOf("\n") >= 0)
          numLinesEst++;
        return prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
      }, 0);
      if (length > 60) {
        return braces[0] + (base === "" ? "" : base + "\n ") + " " + output.join(",\n  ") + " " + braces[1];
      }
      return braces[0] + base + " " + output.join(", ") + " " + braces[1];
    }
    exports.types = require_types();
    function isArray(ar) {
      return Array.isArray(ar);
    }
    exports.isArray = isArray;
    function isBoolean(arg) {
      return typeof arg === "boolean";
    }
    exports.isBoolean = isBoolean;
    function isNull(arg) {
      return arg === null;
    }
    exports.isNull = isNull;
    function isNullOrUndefined(arg) {
      return arg == null;
    }
    exports.isNullOrUndefined = isNullOrUndefined;
    function isNumber(arg) {
      return typeof arg === "number";
    }
    exports.isNumber = isNumber;
    function isString(arg) {
      return typeof arg === "string";
    }
    exports.isString = isString;
    function isSymbol(arg) {
      return typeof arg === "symbol";
    }
    exports.isSymbol = isSymbol;
    function isUndefined(arg) {
      return arg === void 0;
    }
    exports.isUndefined = isUndefined;
    function isRegExp(re) {
      return isObject(re) && objectToString(re) === "[object RegExp]";
    }
    exports.isRegExp = isRegExp;
    exports.types.isRegExp = isRegExp;
    function isObject(arg) {
      return typeof arg === "object" && arg !== null;
    }
    exports.isObject = isObject;
    function isDate(d) {
      return isObject(d) && objectToString(d) === "[object Date]";
    }
    exports.isDate = isDate;
    exports.types.isDate = isDate;
    function isError(e) {
      return isObject(e) && (objectToString(e) === "[object Error]" || e instanceof Error);
    }
    exports.isError = isError;
    exports.types.isNativeError = isError;
    function isFunction(arg) {
      return typeof arg === "function";
    }
    exports.isFunction = isFunction;
    function isPrimitive(arg) {
      return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || typeof arg === "undefined";
    }
    exports.isPrimitive = isPrimitive;
    exports.isBuffer = require_isBufferBrowser();
    function objectToString(o) {
      return Object.prototype.toString.call(o);
    }
    function pad(n) {
      return n < 10 ? "0" + n.toString(10) : n.toString(10);
    }
    var months = [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec"
    ];
    function timestamp() {
      var d = new Date();
      var time = [
        pad(d.getHours()),
        pad(d.getMinutes()),
        pad(d.getSeconds())
      ].join(":");
      return [d.getDate(), months[d.getMonth()], time].join(" ");
    }
    exports.log = function() {
      console.log("%s - %s", timestamp(), exports.format.apply(exports, arguments));
    };
    exports.inherits = require_inherits_browser();
    exports._extend = function(origin, add) {
      if (!add || !isObject(add))
        return origin;
      var keys = Object.keys(add);
      var i = keys.length;
      while (i--) {
        origin[keys[i]] = add[keys[i]];
      }
      return origin;
    };
    function hasOwnProperty2(obj, prop) {
      return Object.prototype.hasOwnProperty.call(obj, prop);
    }
    var kCustomPromisifiedSymbol = typeof Symbol !== "undefined" ? Symbol("util.promisify.custom") : void 0;
    exports.promisify = function promisify(original) {
      if (typeof original !== "function")
        throw new TypeError('The "original" argument must be of type Function');
      if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
        var fn = original[kCustomPromisifiedSymbol];
        if (typeof fn !== "function") {
          throw new TypeError('The "util.promisify.custom" argument must be of type Function');
        }
        Object.defineProperty(fn, kCustomPromisifiedSymbol, {
          value: fn,
          enumerable: false,
          writable: false,
          configurable: true
        });
        return fn;
      }
      function fn() {
        var promiseResolve, promiseReject;
        var promise = new Promise(function(resolve, reject) {
          promiseResolve = resolve;
          promiseReject = reject;
        });
        var args = [];
        for (var i = 0; i < arguments.length; i++) {
          args.push(arguments[i]);
        }
        args.push(function(err, value) {
          if (err) {
            promiseReject(err);
          } else {
            promiseResolve(value);
          }
        });
        try {
          original.apply(this, args);
        } catch (err) {
          promiseReject(err);
        }
        return promise;
      }
      Object.setPrototypeOf(fn, Object.getPrototypeOf(original));
      if (kCustomPromisifiedSymbol)
        Object.defineProperty(fn, kCustomPromisifiedSymbol, {
          value: fn,
          enumerable: false,
          writable: false,
          configurable: true
        });
      return Object.defineProperties(fn, getOwnPropertyDescriptors(original));
    };
    exports.promisify.custom = kCustomPromisifiedSymbol;
    function callbackifyOnRejected(reason, cb) {
      if (!reason) {
        var newReason = new Error("Promise was rejected with a falsy value");
        newReason.reason = reason;
        reason = newReason;
      }
      return cb(reason);
    }
    function callbackify(original) {
      if (typeof original !== "function") {
        throw new TypeError('The "original" argument must be of type Function');
      }
      function callbackified() {
        var args = [];
        for (var i = 0; i < arguments.length; i++) {
          args.push(arguments[i]);
        }
        var maybeCb = args.pop();
        if (typeof maybeCb !== "function") {
          throw new TypeError("The last argument must be of type Function");
        }
        var self2 = this;
        var cb = function() {
          return maybeCb.apply(self2, arguments);
        };
        original.apply(this, args).then(function(ret) {
          process.nextTick(cb.bind(null, null, ret));
        }, function(rej) {
          process.nextTick(callbackifyOnRejected.bind(null, rej, cb));
        });
      }
      Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
      Object.defineProperties(callbackified, getOwnPropertyDescriptors(original));
      return callbackified;
    }
    exports.callbackify = callbackify;
  });

  // lib/define-assertion/format.js
  var require_format = __commonJS((exports, module) => {
    "use strict";
    var inspect = require_util().inspect;
    function format(object) {
      if (object instanceof Error) {
        return object.name;
      }
      return inspect(object);
    }
    module.exports = format;
  });

  // lib/define-assertion/interpolate-pos-arg.js
  var require_interpolate_pos_arg = __commonJS((exports, module) => {
    "use strict";
    var format = require_format();
    function interpolatePosArg(message, values) {
      return message.replace(/\${([0-9]+)}/gi, function(match, num) {
        var index = parseInt(num, 10);
        var value = values[index];
        return format(value);
      });
    }
    module.exports = interpolatePosArg;
  });

  // lib/define-assertion/interpolate-properties.js
  var require_interpolate_properties = __commonJS((exports, module) => {
    "use strict";
    var hasOwnProperty2 = require_lib().prototypes.object.hasOwnProperty;
    var format = require_format();
    function prepareMessage(message) {
      if (!message) {
        return "";
      }
      return message + (/[.:!?]$/.test(message) ? " " : ": ");
    }
    function interpolateProperties(referee, message, properties) {
      return message.replace(/\${(\.\.\.|!)?([a-z]+)}/gi, function(match, prefix, name) {
        if (!hasOwnProperty2(properties, name)) {
          return match;
        }
        var value = properties[name];
        if (prefix === "!") {
          return value;
        }
        if (prefix === "..." && Array.isArray(value)) {
          return value.map(format).join(", ");
        }
        if (name === "customMessage") {
          return prepareMessage(value);
        }
        return format(value);
      });
    }
    module.exports = interpolateProperties;
  });

  // lib/define-assertion/get-message.js
  var require_get_message = __commonJS((exports, module) => {
    "use strict";
    function getMessage(referee, type, name, msg) {
      switch (typeof referee[type][name][msg]) {
        case "function":
          return referee[type][name][msg]();
        case "string":
          return referee[type][name][msg] || msg;
        default:
          return msg;
      }
    }
    module.exports = getMessage;
  });

  // lib/define-assertion/index.js
  var require_define_assertion = __commonJS((exports, module) => {
    "use strict";
    var slice = require_lib().prototypes.array.slice;
    var assertArgNum = require_assert_arg_num();
    var interpolatePosArg = require_interpolate_pos_arg();
    var interpolateProperties = require_interpolate_properties();
    var getMessage = require_get_message();
    function createAssertion(referee, type, name, func, minArgs, messageValues) {
      var assertion = function() {
        var fullName = `${type}.${name}`;
        var failed = false;
        assertArgNum(referee.fail, fullName, arguments, minArgs);
        var args = slice(arguments, 0);
        var namedValues = {};
        var ctx = {
          fail: function(msg) {
            if (typeof messageValues === "function") {
              namedValues = messageValues.apply(this, args);
            }
            failed = true;
            delete this.fail;
            var message = getMessage(referee, type, name, msg);
            message = interpolatePosArg(message, args);
            message = interpolateProperties(referee, message, this);
            message = interpolateProperties(referee, message, namedValues);
            var operator = `${type}.${name}`;
            var errorProperties = {
              operator
            };
            if (type === "assert") {
              if (namedValues.hasOwnProperty("actual") && namedValues.hasOwnProperty("expected")) {
                errorProperties.actual = namedValues.actual;
                errorProperties.expected = namedValues.expected;
              }
            }
            referee.fail(`[${operator}] ${message}`, errorProperties);
            return false;
          }
        };
        var result = func.apply(ctx, arguments);
        if (typeof Promise === "function" && result instanceof Promise) {
          return result.then(function() {
            referee.pass(["pass", fullName].concat(args));
          });
        }
        if (!result && !failed) {
          ctx.fail("message");
        }
        if (!failed) {
          referee.pass(["pass", fullName].concat(args));
        }
        return void 0;
      };
      return assertion;
    }
    function defineAssertion(referee, type, name, func, minArgs, messageValues) {
      referee[type][name] = function() {
        var assertion = createAssertion(referee, type, name, func, minArgs, messageValues);
        return assertion.apply(null, arguments);
      };
    }
    module.exports = defineAssertion;
  });

  // lib/create-add.js
  var require_create_add = __commonJS((exports, module) => {
    "use strict";
    var defineAssertion = require_define_assertion();
    var validFunctionName = /^[_$a-zA-Z\xA0-\uFFFF][_$a-zA-Z0-9\xA0-\uFFFF]*$/;
    function verifyArguments(name, options) {
      if (typeof name !== "string" || !validFunctionName.test(name)) {
        throw new TypeError(`'name' argument must be a non-empty string matching ${validFunctionName.toString()}`);
      }
      if (typeof options !== "object" || Object.keys(options).length === 0) {
        throw new TypeError("'options' argument must be a non-empty object");
      }
      if (typeof options.assert !== "function" || options.assert.length === 0) {
        throw new TypeError("'assert' option must be a Function, taking at least one argument");
      }
      if (typeof options.refute !== "undefined" && (typeof options.refute !== "function" || options.refute.length === 0)) {
        throw new TypeError("'refute' option must be a Function, taking at least one argument");
      }
      ["assertMessage", "refuteMessage"].forEach((m) => {
        if (!isValidMessageOption(options[m])) {
          throw new TypeError(`'${m}' option must be a non-empty String or Function`);
        }
      });
    }
    function isValidMessageOption(message) {
      if (typeof message === "undefined") {
        return true;
      }
      if (typeof message === "function") {
        return true;
      }
      if (typeof message === "string" && message.length > 0) {
        return true;
      }
      return false;
    }
    function createAdd(referee) {
      function add(name, options) {
        verifyArguments(name, options);
        var refuteArgs = options.refute ? options.refute.length : options.assert.length;
        if (!options.refute) {
          options.refute = function() {
            return !options.assert.apply(this, arguments);
          };
        }
        defineAssertion(referee, "assert", name, options.assert, options.assert.length, options.values);
        defineAssertion(referee, "refute", name, options.refute, refuteArgs, options.values);
        referee.assert[name].message = options.assertMessage;
        referee.refute[name].message = options.refuteMessage;
        if (!options.expectation) {
          return;
        }
        referee.assert[name].expectationName = options.expectation;
        referee.refute[name].expectationName = options.expectation;
      }
      return add;
    }
    module.exports = createAdd;
  });

  // lib/create-assert.js
  var require_create_assert = __commonJS((exports, module) => {
    "use strict";
    var assertArgNum = require_assert_arg_num();
    function createAssert(referee) {
      function assert(actual, message) {
        assertArgNum(referee.fail, "assert", arguments, 1);
        if (!actual) {
          referee.fail(message || `[assert] Expected ${String(actual)} to be truthy`);
          return;
        }
        referee.emit("pass", "assert", message || "", actual);
      }
      assert.toString = function() {
        return "referee.assert()";
      };
      return assert;
    }
    module.exports = createAssert;
  });

  // lib/create-refute.js
  var require_create_refute = __commonJS((exports, module) => {
    "use strict";
    var assertArgNum = require_assert_arg_num();
    function createRefute(referee) {
      function refute(actual, message) {
        assertArgNum(referee.fail, "refute", arguments, 1);
        if (actual) {
          referee.fail(message || `[refute] Expected ${String(actual)} to be falsy`);
          return;
        }
        referee.emit("pass", "refute", message || "", actual);
      }
      refute.toString = function() {
        return "referee.refute()";
      };
      return refute;
    }
    module.exports = createRefute;
  });

  // lib/expect.js
  var require_expect = __commonJS((exports, module) => {
    "use strict";
    function expect(actual) {
      var expectation = Object.assign(Object.create(expect.expectation), {
        actual,
        assertMode: true
      });
      expectation.not = Object.assign(Object.create(expectation), {
        assertMode: false
      });
      return expectation;
    }
    expect.expectation = Object.create(null);
    expect.wrapAssertion = function wrapAssertion(assertion, expectation, referee) {
      expect.expectation[expectation] = function() {
        var args = [this.actual].concat(Array.from(arguments));
        var type = this.assertMode ? "assert" : "refute";
        var callFunc;
        if (assertion === "assert") {
          callFunc = this.assertMode ? referee.assert : referee.refute;
        } else if (assertion === "refute") {
          callFunc = this.assertMode ? referee.refute : referee.assert;
        } else {
          callFunc = referee[type][assertion];
        }
        try {
          return callFunc.apply(referee.expect, args);
        } catch (e) {
          e.message = e.message.replace(`[${type}.${assertion}]`, `[expect.${this.assertMode ? "" : "not."}${expectation}]`);
          throw e;
        }
      };
    };
    expect.init = function init(referee) {
      Object.keys(referee.assert).forEach(function(name) {
        var expectationName = referee.assert[name].expectationName;
        if (expectationName) {
          expect.wrapAssertion(name, expectationName, referee);
        }
      });
      expect.wrapAssertion("assert", "toBeTruthy", referee);
      expect.wrapAssertion("refute", "toBeFalsy", referee);
    };
    module.exports = expect;
  });

  // lib/create-expect.js
  var require_create_expect = __commonJS((exports, module) => {
    "use strict";
    var expectImpl = require_expect();
    function createExpect(referee) {
      function expect() {
        expectImpl.init(referee);
        return expectImpl.apply(referee, arguments);
      }
      return expect;
    }
    module.exports = createExpect;
  });

  // lib/create-fail.js
  var require_create_fail = __commonJS((exports, module) => {
    "use strict";
    function createFail(referee) {
      function fail(message, errorProperties) {
        var exception = new Error(message);
        exception.name = "AssertionError";
        exception.code = "ERR_ASSERTION";
        if (errorProperties) {
          Object.keys(errorProperties).forEach(function(key) {
            exception[key] = errorProperties[key];
          });
        }
        try {
          throw exception;
        } catch (e) {
          referee.emit("failure", e);
        }
        if (typeof referee.throwOnFailure !== "boolean" || referee.throwOnFailure) {
          throw exception;
        }
      }
      return fail;
    }
    module.exports = createFail;
  });

  // lib/create-pass.js
  var require_create_pass = __commonJS((exports, module) => {
    "use strict";
    function createPass(referee) {
      function pass(message) {
        referee.emit.apply(referee, message);
      }
      return pass;
    }
    module.exports = createPass;
  });

  // lib/create-verifier.js
  var require_create_verifier = __commonJS((exports, module) => {
    "use strict";
    function createVerifier(referee) {
      function verifier() {
        var count = 0;
        function incrementCount() {
          count += 1;
        }
        referee.on("pass", incrementCount);
        referee.on("failure", incrementCount);
        function verify(expected) {
          referee.off("pass", incrementCount);
          referee.off("failure", incrementCount);
          if (typeof expected !== "undefined" && (typeof expected !== "number" || expected < 1)) {
            throw new TypeError("expected argument must be a number >= 1");
          }
          if (expected && count !== expected) {
            throw new Error(`Expected assertion count to be ${expected} but was ${count}`);
          }
          if (count === 0) {
            throw new Error("Expected assertion count to be at least 1, but was 0");
          }
        }
        Object.defineProperty(verify, "count", {
          get: function() {
            return count;
          }
        });
        return verify;
      }
      return verifier;
    }
    module.exports = createVerifier;
  });

  // node_modules/@sinonjs/samsam/lib/is-nan.js
  var require_is_nan = __commonJS((exports, module) => {
    "use strict";
    function isNaN2(value) {
      return typeof value === "number" && value !== value;
    }
    module.exports = isNaN2;
  });

  // node_modules/@sinonjs/samsam/lib/is-neg-zero.js
  var require_is_neg_zero = __commonJS((exports, module) => {
    "use strict";
    function isNegZero(value) {
      return value === 0 && 1 / value === -Infinity;
    }
    module.exports = isNegZero;
  });

  // node_modules/@sinonjs/samsam/lib/identical.js
  var require_identical = __commonJS((exports, module) => {
    "use strict";
    var isNaN2 = require_is_nan();
    var isNegZero = require_is_neg_zero();
    function identical(obj1, obj2) {
      if (obj1 === obj2 || isNaN2(obj1) && isNaN2(obj2)) {
        return obj1 !== 0 || isNegZero(obj1) === isNegZero(obj2);
      }
      return false;
    }
    module.exports = identical;
  });

  // node_modules/@sinonjs/samsam/lib/get-class.js
  var require_get_class = __commonJS((exports, module) => {
    "use strict";
    var toString = require_lib().prototypes.object.toString;
    function getClass(value) {
      return toString(value).split(/[ \]]/)[1];
    }
    module.exports = getClass;
  });

  // node_modules/@sinonjs/samsam/lib/is-arguments.js
  var require_is_arguments2 = __commonJS((exports, module) => {
    "use strict";
    var getClass = require_get_class();
    function isArguments(object) {
      return getClass(object) === "Arguments";
    }
    module.exports = isArguments;
  });

  // node_modules/@sinonjs/samsam/lib/is-element.js
  var require_is_element = __commonJS((exports, module) => {
    "use strict";
    var div = typeof document !== "undefined" && document.createElement("div");
    function isElement(object) {
      if (!object || object.nodeType !== 1 || !div) {
        return false;
      }
      try {
        object.appendChild(div);
        object.removeChild(div);
      } catch (e) {
        return false;
      }
      return true;
    }
    module.exports = isElement;
  });

  // node_modules/@sinonjs/samsam/lib/is-set.js
  var require_is_set = __commonJS((exports, module) => {
    "use strict";
    function isSet(val) {
      return typeof Set !== "undefined" && val instanceof Set || false;
    }
    module.exports = isSet;
  });

  // node_modules/@sinonjs/samsam/lib/is-map.js
  var require_is_map = __commonJS((exports, module) => {
    "use strict";
    function isMap(value) {
      return typeof Map !== "undefined" && value instanceof Map;
    }
    module.exports = isMap;
  });

  // node_modules/@sinonjs/samsam/lib/is-date.js
  var require_is_date = __commonJS((exports, module) => {
    "use strict";
    function isDate(value) {
      return value instanceof Date;
    }
    module.exports = isDate;
  });

  // node_modules/@sinonjs/samsam/lib/is-object.js
  var require_is_object = __commonJS((exports, module) => {
    "use strict";
    function isObject(value) {
      return typeof value === "object" && value !== null && !(value instanceof Boolean) && !(value instanceof Date) && !(value instanceof Error) && !(value instanceof Number) && !(value instanceof RegExp) && !(value instanceof String);
    }
    module.exports = isObject;
  });

  // node_modules/@sinonjs/samsam/lib/is-subset.js
  var require_is_subset = __commonJS((exports, module) => {
    "use strict";
    var forEach = require_lib().prototypes.set.forEach;
    function isSubset(s1, s2, compare) {
      var allContained = true;
      forEach(s1, function(v1) {
        var includes = false;
        forEach(s2, function(v2) {
          if (compare(v2, v1)) {
            includes = true;
          }
        });
        allContained = allContained && includes;
      });
      return allContained;
    }
    module.exports = isSubset;
  });

  // node_modules/@sinonjs/samsam/lib/deep-equal.js
  var require_deep_equal = __commonJS((exports, module) => {
    "use strict";
    var valueToString = require_lib().valueToString;
    var className = require_lib().className;
    var typeOf = require_lib().typeOf;
    var arrayProto = require_lib().prototypes.array;
    var objectProto = require_lib().prototypes.object;
    var mapForEach = require_lib().prototypes.map.forEach;
    var getClass = require_get_class();
    var identical = require_identical();
    var isArguments = require_is_arguments2();
    var isDate = require_is_date();
    var isElement = require_is_element();
    var isMap = require_is_map();
    var isNaN2 = require_is_nan();
    var isObject = require_is_object();
    var isSet = require_is_set();
    var isSubset = require_is_subset();
    var concat = arrayProto.concat;
    var every = arrayProto.every;
    var push = arrayProto.push;
    var getTime = Date.prototype.getTime;
    var hasOwnProperty2 = objectProto.hasOwnProperty;
    var indexOf = arrayProto.indexOf;
    var keys = Object.keys;
    var getOwnPropertySymbols = Object.getOwnPropertySymbols;
    function deepEqualCyclic(actual, expectation, match) {
      var actualObjects = [];
      var expectationObjects = [];
      var actualPaths = [];
      var expectationPaths = [];
      var compared = {};
      return function deepEqual(actualObj, expectationObj, actualPath, expectationPath) {
        if (match && match.isMatcher(expectationObj)) {
          if (match.isMatcher(actualObj)) {
            return actualObj === expectationObj;
          }
          return expectationObj.test(actualObj);
        }
        var actualType = typeof actualObj;
        var expectationType = typeof expectationObj;
        if (actualObj === expectationObj || isNaN2(actualObj) || isNaN2(expectationObj) || actualObj === null || expectationObj === null || actualObj === void 0 || expectationObj === void 0 || actualType !== "object" || expectationType !== "object") {
          return identical(actualObj, expectationObj);
        }
        if (isElement(actualObj) || isElement(expectationObj)) {
          return false;
        }
        var isActualDate = isDate(actualObj);
        var isExpectationDate = isDate(expectationObj);
        if (isActualDate || isExpectationDate) {
          if (!isActualDate || !isExpectationDate || getTime.call(actualObj) !== getTime.call(expectationObj)) {
            return false;
          }
        }
        if (actualObj instanceof RegExp && expectationObj instanceof RegExp) {
          if (valueToString(actualObj) !== valueToString(expectationObj)) {
            return false;
          }
        }
        if (actualObj instanceof Promise && expectationObj instanceof Promise) {
          return actualObj === expectationObj;
        }
        if (actualObj instanceof Error && expectationObj instanceof Error) {
          return actualObj === expectationObj;
        }
        var actualClass = getClass(actualObj);
        var expectationClass = getClass(expectationObj);
        var actualKeys = keys(actualObj);
        var expectationKeys = keys(expectationObj);
        var actualName = className(actualObj);
        var expectationName = className(expectationObj);
        var expectationSymbols = typeOf(getOwnPropertySymbols) === "function" ? getOwnPropertySymbols(expectationObj) : [];
        var expectationKeysAndSymbols = concat(expectationKeys, expectationSymbols);
        if (isArguments(actualObj) || isArguments(expectationObj)) {
          if (actualObj.length !== expectationObj.length) {
            return false;
          }
        } else {
          if (actualType !== expectationType || actualClass !== expectationClass || actualKeys.length !== expectationKeys.length || actualName && expectationName && actualName !== expectationName) {
            return false;
          }
        }
        if (isSet(actualObj) || isSet(expectationObj)) {
          if (!isSet(actualObj) || !isSet(expectationObj) || actualObj.size !== expectationObj.size) {
            return false;
          }
          return isSubset(actualObj, expectationObj, deepEqual);
        }
        if (isMap(actualObj) || isMap(expectationObj)) {
          if (!isMap(actualObj) || !isMap(expectationObj) || actualObj.size !== expectationObj.size) {
            return false;
          }
          var mapsDeeplyEqual = true;
          mapForEach(actualObj, function(value, key) {
            mapsDeeplyEqual = mapsDeeplyEqual && deepEqualCyclic(value, expectationObj.get(key));
          });
          return mapsDeeplyEqual;
        }
        return every(expectationKeysAndSymbols, function(key) {
          if (!hasOwnProperty2(actualObj, key)) {
            return false;
          }
          var actualValue = actualObj[key];
          var expectationValue = expectationObj[key];
          var actualObject = isObject(actualValue);
          var expectationObject = isObject(expectationValue);
          var actualIndex = actualObject ? indexOf(actualObjects, actualValue) : -1;
          var expectationIndex = expectationObject ? indexOf(expectationObjects, expectationValue) : -1;
          var newActualPath = actualIndex !== -1 ? actualPaths[actualIndex] : `${actualPath}[${JSON.stringify(key)}]`;
          var newExpectationPath = expectationIndex !== -1 ? expectationPaths[expectationIndex] : `${expectationPath}[${JSON.stringify(key)}]`;
          var combinedPath = newActualPath + newExpectationPath;
          if (compared[combinedPath]) {
            return true;
          }
          if (actualIndex === -1 && actualObject) {
            push(actualObjects, actualValue);
            push(actualPaths, newActualPath);
          }
          if (expectationIndex === -1 && expectationObject) {
            push(expectationObjects, expectationValue);
            push(expectationPaths, newExpectationPath);
          }
          if (actualObject && expectationObject) {
            compared[combinedPath] = true;
          }
          return deepEqual(actualValue, expectationValue, newActualPath, newExpectationPath);
        });
      }(actual, expectation, "$1", "$2");
    }
    deepEqualCyclic.use = function(match) {
      return function deepEqual(a, b) {
        return deepEqualCyclic(a, b, match);
      };
    };
    module.exports = deepEqualCyclic;
  });

  // node_modules/@sinonjs/samsam/lib/array-types.js
  var require_array_types = __commonJS((exports, module) => {
    "use strict";
    var ARRAY_TYPES = [
      Array,
      Int8Array,
      Uint8Array,
      Uint8ClampedArray,
      Int16Array,
      Uint16Array,
      Int32Array,
      Uint32Array,
      Float32Array,
      Float64Array
    ];
    module.exports = ARRAY_TYPES;
  });

  // node_modules/@sinonjs/samsam/lib/is-array-type.js
  var require_is_array_type = __commonJS((exports, module) => {
    "use strict";
    var functionName = require_lib().functionName;
    var indexOf = require_lib().prototypes.array.indexOf;
    var map = require_lib().prototypes.array.map;
    var ARRAY_TYPES = require_array_types();
    var type = require_type_detect();
    function isArrayType(object) {
      return indexOf(map(ARRAY_TYPES, functionName), type(object)) !== -1;
    }
    module.exports = isArrayType;
  });

  // node_modules/lodash.get/index.js
  var require_lodash = __commonJS((exports, module) => {
    var FUNC_ERROR_TEXT = "Expected a function";
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var INFINITY = 1 / 0;
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var symbolTag = "[object Symbol]";
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
    var reIsPlainProp = /^\w*$/;
    var reLeadingDot = /^\./;
    var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reEscapeChar = /\\(\\)?/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    function isHostObject(value) {
      var result = false;
      if (value != null && typeof value.toString != "function") {
        try {
          result = !!(value + "");
        } catch (e) {
        }
      }
      return result;
    }
    var arrayProto = Array.prototype;
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var coreJsData = root["__core-js_shared__"];
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    var funcToString = funcProto.toString;
    var hasOwnProperty2 = objectProto.hasOwnProperty;
    var objectToString = objectProto.toString;
    var reIsNative = RegExp("^" + funcToString.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
    var Symbol2 = root.Symbol;
    var splice = arrayProto.splice;
    var Map2 = getNative(root, "Map");
    var nativeCreate = getNative(Object, "create");
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolToString = symbolProto ? symbolProto.toString : void 0;
    function Hash(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
    }
    function hashDelete(key) {
      return this.has(key) && delete this.__data__[key];
    }
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty2.call(data, key) ? data[key] : void 0;
    }
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty2.call(data, key);
    }
    function hashSet(key, value) {
      var data = this.__data__;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function ListCache(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function listCacheClear() {
      this.__data__ = [];
    }
    function listCacheDelete(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      return true;
    }
    function listCacheGet(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      return index < 0 ? void 0 : data[index][1];
    }
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    function listCacheSet(key, value) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    function MapCache(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function mapCacheClear() {
      this.__data__ = {
        hash: new Hash(),
        map: new (Map2 || ListCache)(),
        string: new Hash()
      };
    }
    function mapCacheDelete(key) {
      return getMapData(this, key)["delete"](key);
    }
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    function mapCacheSet(key, value) {
      getMapData(this, key).set(key, value);
      return this;
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    function baseGet(object, path) {
      path = isKey(path, object) ? [path] : castPath(path);
      var index = 0, length = path.length;
      while (object != null && index < length) {
        object = object[toKey(path[index++])];
      }
      return index && index == length ? object : void 0;
    }
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    function baseToString(value) {
      if (typeof value == "string") {
        return value;
      }
      if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : "";
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    function castPath(value) {
      return isArray(value) ? value : stringToPath(value);
    }
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    function isKey(value, object) {
      if (isArray(value)) {
        return false;
      }
      var type = typeof value;
      if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
        return true;
      }
      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
    }
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    var stringToPath = memoize(function(string) {
      string = toString(string);
      var result = [];
      if (reLeadingDot.test(string)) {
        result.push("");
      }
      string.replace(rePropName, function(match, number, quote, string2) {
        result.push(quote ? string2.replace(reEscapeChar, "$1") : number || match);
      });
      return result;
    });
    function toKey(value) {
      if (typeof value == "string" || isSymbol(value)) {
        return value;
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {
        }
        try {
          return func + "";
        } catch (e) {
        }
      }
      return "";
    }
    function memoize(func, resolver) {
      if (typeof func != "function" || resolver && typeof resolver != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var memoized = function() {
        var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
        if (cache.has(key)) {
          return cache.get(key);
        }
        var result = func.apply(this, args);
        memoized.cache = cache.set(key, result);
        return result;
      };
      memoized.cache = new (memoize.Cache || MapCache)();
      return memoized;
    }
    memoize.Cache = MapCache;
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    var isArray = Array.isArray;
    function isFunction(value) {
      var tag = isObject(value) ? objectToString.call(value) : "";
      return tag == funcTag || tag == genTag;
    }
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    function toString(value) {
      return value == null ? "" : baseToString(value);
    }
    function get(object, path, defaultValue) {
      var result = object == null ? void 0 : baseGet(object, path);
      return result === void 0 ? defaultValue : result;
    }
    module.exports = get;
  });

  // node_modules/@sinonjs/samsam/lib/iterable-to-string.js
  var require_iterable_to_string = __commonJS((exports, module) => {
    "use strict";
    var slice = require_lib().prototypes.string.slice;
    var typeOf = require_lib().typeOf;
    var valueToString = require_lib().valueToString;
    function iterableToString(obj) {
      if (typeOf(obj) === "map") {
        return mapToString(obj);
      }
      return genericIterableToString(obj);
    }
    function mapToString(map) {
      var representation = "";
      map.forEach(function(value, key) {
        representation += `[${stringify(key)},${stringify(value)}],`;
      });
      representation = slice(representation, 0, -1);
      return representation;
    }
    function genericIterableToString(iterable) {
      var representation = "";
      iterable.forEach(function(value) {
        representation += `${stringify(value)},`;
      });
      representation = slice(representation, 0, -1);
      return representation;
    }
    function stringify(item) {
      return typeof item === "string" ? `'${item}'` : valueToString(item);
    }
    module.exports = iterableToString;
  });

  // node_modules/@sinonjs/samsam/lib/create-matcher/matcher-prototype.js
  var require_matcher_prototype = __commonJS((exports, module) => {
    "use strict";
    var matcherPrototype = {
      toString: function() {
        return this.message;
      }
    };
    matcherPrototype.or = function(valueOrMatcher) {
      var createMatcher = require_create_matcher();
      var isMatcher = createMatcher.isMatcher;
      if (!arguments.length) {
        throw new TypeError("Matcher expected");
      }
      var m2 = isMatcher(valueOrMatcher) ? valueOrMatcher : createMatcher(valueOrMatcher);
      var m1 = this;
      var or = Object.create(matcherPrototype);
      or.test = function(actual) {
        return m1.test(actual) || m2.test(actual);
      };
      or.message = `${m1.message}.or(${m2.message})`;
      return or;
    };
    matcherPrototype.and = function(valueOrMatcher) {
      var createMatcher = require_create_matcher();
      var isMatcher = createMatcher.isMatcher;
      if (!arguments.length) {
        throw new TypeError("Matcher expected");
      }
      var m2 = isMatcher(valueOrMatcher) ? valueOrMatcher : createMatcher(valueOrMatcher);
      var m1 = this;
      var and = Object.create(matcherPrototype);
      and.test = function(actual) {
        return m1.test(actual) && m2.test(actual);
      };
      and.message = `${m1.message}.and(${m2.message})`;
      return and;
    };
    module.exports = matcherPrototype;
  });

  // node_modules/@sinonjs/samsam/lib/create-matcher/is-matcher.js
  var require_is_matcher = __commonJS((exports, module) => {
    "use strict";
    var isPrototypeOf = require_lib().prototypes.object.isPrototypeOf;
    var matcherPrototype = require_matcher_prototype();
    function isMatcher(object) {
      return isPrototypeOf(matcherPrototype, object);
    }
    module.exports = isMatcher;
  });

  // node_modules/@sinonjs/samsam/lib/create-matcher/assert-matcher.js
  var require_assert_matcher = __commonJS((exports, module) => {
    "use strict";
    var isMatcher = require_is_matcher();
    function assertMatcher(value) {
      if (!isMatcher(value)) {
        throw new TypeError("Matcher expected");
      }
    }
    module.exports = assertMatcher;
  });

  // node_modules/@sinonjs/samsam/lib/create-matcher/assert-method-exists.js
  var require_assert_method_exists = __commonJS((exports, module) => {
    "use strict";
    function assertMethodExists(value, method, name, methodPath) {
      if (value[method] === null || value[method] === void 0) {
        throw new TypeError(`Expected ${name} to have method ${methodPath}`);
      }
    }
    module.exports = assertMethodExists;
  });

  // node_modules/@sinonjs/samsam/lib/create-matcher/assert-type.js
  var require_assert_type = __commonJS((exports, module) => {
    "use strict";
    var typeOf = require_lib().typeOf;
    function assertType(value, type, name) {
      var actual = typeOf(value);
      if (actual !== type) {
        throw new TypeError(`Expected type of ${name} to be ${type}, but was ${actual}`);
      }
    }
    module.exports = assertType;
  });

  // node_modules/@sinonjs/samsam/lib/create-matcher/is-iterable.js
  var require_is_iterable = __commonJS((exports, module) => {
    "use strict";
    var typeOf = require_lib().typeOf;
    function isIterable(value) {
      return Boolean(value) && typeOf(value.forEach) === "function";
    }
    module.exports = isIterable;
  });

  // node_modules/@sinonjs/samsam/lib/create-matcher/match-object.js
  var require_match_object = __commonJS((exports, module) => {
    "use strict";
    var every = require_lib().prototypes.array.every;
    var concat = require_lib().prototypes.array.concat;
    var typeOf = require_lib().typeOf;
    var deepEqualFactory = require_deep_equal().use;
    var isMatcher = require_is_matcher();
    var keys = Object.keys;
    var getOwnPropertySymbols = Object.getOwnPropertySymbols;
    function matchObject(actual, expectation, matcher) {
      var deepEqual = deepEqualFactory(matcher);
      if (actual === null || actual === void 0) {
        return false;
      }
      var expectedKeys = keys(expectation);
      if (typeOf(getOwnPropertySymbols) === "function") {
        expectedKeys = concat(expectedKeys, getOwnPropertySymbols(expectation));
      }
      return every(expectedKeys, function(key) {
        var exp = expectation[key];
        var act = actual[key];
        if (isMatcher(exp)) {
          if (!exp.test(act)) {
            return false;
          }
        } else if (typeOf(exp) === "object") {
          if (!matchObject(act, exp, matcher)) {
            return false;
          }
        } else if (!deepEqual(act, exp)) {
          return false;
        }
        return true;
      });
    }
    module.exports = matchObject;
  });

  // node_modules/@sinonjs/samsam/lib/create-matcher/type-map.js
  var require_type_map = __commonJS((exports, module) => {
    "use strict";
    var functionName = require_lib().functionName;
    var join = require_lib().prototypes.array.join;
    var map = require_lib().prototypes.array.map;
    var stringIndexOf = require_lib().prototypes.string.indexOf;
    var valueToString = require_lib().valueToString;
    var matchObject = require_match_object();
    var createTypeMap = function(match) {
      return {
        function: function(m, expectation, message) {
          m.test = expectation;
          m.message = message || `match(${functionName(expectation)})`;
        },
        number: function(m, expectation) {
          m.test = function(actual) {
            return expectation == actual;
          };
        },
        object: function(m, expectation) {
          var array = [];
          if (typeof expectation.test === "function") {
            m.test = function(actual) {
              return expectation.test(actual) === true;
            };
            m.message = `match(${functionName(expectation.test)})`;
            return m;
          }
          array = map(Object.keys(expectation), function(key) {
            return `${key}: ${valueToString(expectation[key])}`;
          });
          m.test = function(actual) {
            return matchObject(actual, expectation, match);
          };
          m.message = `match(${join(array, ", ")})`;
          return m;
        },
        regexp: function(m, expectation) {
          m.test = function(actual) {
            return typeof actual === "string" && expectation.test(actual);
          };
        },
        string: function(m, expectation) {
          m.test = function(actual) {
            return typeof actual === "string" && stringIndexOf(actual, expectation) !== -1;
          };
          m.message = `match("${expectation}")`;
        }
      };
    };
    module.exports = createTypeMap;
  });

  // node_modules/@sinonjs/samsam/lib/create-matcher.js
  var require_create_matcher = __commonJS((exports, module) => {
    "use strict";
    var arrayProto = require_lib().prototypes.array;
    var deepEqual = require_deep_equal().use(createMatcher);
    var every = require_lib().every;
    var functionName = require_lib().functionName;
    var get = require_lodash();
    var iterableToString = require_iterable_to_string();
    var objectProto = require_lib().prototypes.object;
    var typeOf = require_lib().typeOf;
    var valueToString = require_lib().valueToString;
    var assertMatcher = require_assert_matcher();
    var assertMethodExists = require_assert_method_exists();
    var assertType = require_assert_type();
    var isIterable = require_is_iterable();
    var isMatcher = require_is_matcher();
    var matcherPrototype = require_matcher_prototype();
    var arrayIndexOf = arrayProto.indexOf;
    var some = arrayProto.some;
    var hasOwnProperty2 = objectProto.hasOwnProperty;
    var objectToString = objectProto.toString;
    var TYPE_MAP = require_type_map()(createMatcher);
    function createMatcher(expectation, message) {
      var m = Object.create(matcherPrototype);
      var type = typeOf(expectation);
      if (message !== void 0 && typeof message !== "string") {
        throw new TypeError("Message should be a string");
      }
      if (arguments.length > 2) {
        throw new TypeError(`Expected 1 or 2 arguments, received ${arguments.length}`);
      }
      if (type in TYPE_MAP) {
        TYPE_MAP[type](m, expectation, message);
      } else {
        m.test = function(actual) {
          return deepEqual(actual, expectation);
        };
      }
      if (!m.message) {
        m.message = `match(${valueToString(expectation)})`;
      }
      return m;
    }
    createMatcher.isMatcher = isMatcher;
    createMatcher.any = createMatcher(function() {
      return true;
    }, "any");
    createMatcher.defined = createMatcher(function(actual) {
      return actual !== null && actual !== void 0;
    }, "defined");
    createMatcher.truthy = createMatcher(function(actual) {
      return Boolean(actual);
    }, "truthy");
    createMatcher.falsy = createMatcher(function(actual) {
      return !actual;
    }, "falsy");
    createMatcher.same = function(expectation) {
      return createMatcher(function(actual) {
        return expectation === actual;
      }, `same(${valueToString(expectation)})`);
    };
    createMatcher.in = function(arrayOfExpectations) {
      if (typeOf(arrayOfExpectations) !== "array") {
        throw new TypeError("array expected");
      }
      return createMatcher(function(actual) {
        return some(arrayOfExpectations, function(expectation) {
          return expectation === actual;
        });
      }, `in(${valueToString(arrayOfExpectations)})`);
    };
    createMatcher.typeOf = function(type) {
      assertType(type, "string", "type");
      return createMatcher(function(actual) {
        return typeOf(actual) === type;
      }, `typeOf("${type}")`);
    };
    createMatcher.instanceOf = function(type) {
      if (typeof Symbol === "undefined" || typeof Symbol.hasInstance === "undefined") {
        assertType(type, "function", "type");
      } else {
        assertMethodExists(type, Symbol.hasInstance, "type", "[Symbol.hasInstance]");
      }
      return createMatcher(function(actual) {
        return actual instanceof type;
      }, `instanceOf(${functionName(type) || objectToString(type)})`);
    };
    function createPropertyMatcher(propertyTest, messagePrefix) {
      return function(property, value) {
        assertType(property, "string", "property");
        var onlyProperty = arguments.length === 1;
        var message = `${messagePrefix}("${property}"`;
        if (!onlyProperty) {
          message += `, ${valueToString(value)}`;
        }
        message += ")";
        return createMatcher(function(actual) {
          if (actual === void 0 || actual === null || !propertyTest(actual, property)) {
            return false;
          }
          return onlyProperty || deepEqual(actual[property], value);
        }, message);
      };
    }
    createMatcher.has = createPropertyMatcher(function(actual, property) {
      if (typeof actual === "object") {
        return property in actual;
      }
      return actual[property] !== void 0;
    }, "has");
    createMatcher.hasOwn = createPropertyMatcher(function(actual, property) {
      return hasOwnProperty2(actual, property);
    }, "hasOwn");
    createMatcher.hasNested = function(property, value) {
      assertType(property, "string", "property");
      var onlyProperty = arguments.length === 1;
      var message = `hasNested("${property}"`;
      if (!onlyProperty) {
        message += `, ${valueToString(value)}`;
      }
      message += ")";
      return createMatcher(function(actual) {
        if (actual === void 0 || actual === null || get(actual, property) === void 0) {
          return false;
        }
        return onlyProperty || deepEqual(get(actual, property), value);
      }, message);
    };
    var jsonParseResultTypes = {
      null: true,
      boolean: true,
      number: true,
      string: true,
      object: true,
      array: true
    };
    createMatcher.json = function(value) {
      if (!jsonParseResultTypes[typeOf(value)]) {
        throw new TypeError("Value cannot be the result of JSON.parse");
      }
      var message = `json(${JSON.stringify(value, null, "  ")})`;
      return createMatcher(function(actual) {
        var parsed;
        try {
          parsed = JSON.parse(actual);
        } catch (e) {
          return false;
        }
        return deepEqual(parsed, value);
      }, message);
    };
    createMatcher.every = function(predicate) {
      assertMatcher(predicate);
      return createMatcher(function(actual) {
        if (typeOf(actual) === "object") {
          return every(Object.keys(actual), function(key) {
            return predicate.test(actual[key]);
          });
        }
        return isIterable(actual) && every(actual, function(element) {
          return predicate.test(element);
        });
      }, `every(${predicate.message})`);
    };
    createMatcher.some = function(predicate) {
      assertMatcher(predicate);
      return createMatcher(function(actual) {
        if (typeOf(actual) === "object") {
          return !every(Object.keys(actual), function(key) {
            return !predicate.test(actual[key]);
          });
        }
        return isIterable(actual) && !every(actual, function(element) {
          return !predicate.test(element);
        });
      }, `some(${predicate.message})`);
    };
    createMatcher.array = createMatcher.typeOf("array");
    createMatcher.array.deepEquals = function(expectation) {
      return createMatcher(function(actual) {
        var sameLength = actual.length === expectation.length;
        return typeOf(actual) === "array" && sameLength && every(actual, function(element, index) {
          var expected = expectation[index];
          return typeOf(expected) === "array" && typeOf(element) === "array" ? createMatcher.array.deepEquals(expected).test(element) : deepEqual(expected, element);
        });
      }, `deepEquals([${iterableToString(expectation)}])`);
    };
    createMatcher.array.startsWith = function(expectation) {
      return createMatcher(function(actual) {
        return typeOf(actual) === "array" && every(expectation, function(expectedElement, index) {
          return actual[index] === expectedElement;
        });
      }, `startsWith([${iterableToString(expectation)}])`);
    };
    createMatcher.array.endsWith = function(expectation) {
      return createMatcher(function(actual) {
        var offset = actual.length - expectation.length;
        return typeOf(actual) === "array" && every(expectation, function(expectedElement, index) {
          return actual[offset + index] === expectedElement;
        });
      }, `endsWith([${iterableToString(expectation)}])`);
    };
    createMatcher.array.contains = function(expectation) {
      return createMatcher(function(actual) {
        return typeOf(actual) === "array" && every(expectation, function(expectedElement) {
          return arrayIndexOf(actual, expectedElement) !== -1;
        });
      }, `contains([${iterableToString(expectation)}])`);
    };
    createMatcher.map = createMatcher.typeOf("map");
    createMatcher.map.deepEquals = function mapDeepEquals(expectation) {
      return createMatcher(function(actual) {
        var sameLength = actual.size === expectation.size;
        return typeOf(actual) === "map" && sameLength && every(actual, function(element, key) {
          return expectation.has(key) && expectation.get(key) === element;
        });
      }, `deepEquals(Map[${iterableToString(expectation)}])`);
    };
    createMatcher.map.contains = function mapContains(expectation) {
      return createMatcher(function(actual) {
        return typeOf(actual) === "map" && every(expectation, function(element, key) {
          return actual.has(key) && actual.get(key) === element;
        });
      }, `contains(Map[${iterableToString(expectation)}])`);
    };
    createMatcher.set = createMatcher.typeOf("set");
    createMatcher.set.deepEquals = function setDeepEquals(expectation) {
      return createMatcher(function(actual) {
        var sameLength = actual.size === expectation.size;
        return typeOf(actual) === "set" && sameLength && every(actual, function(element) {
          return expectation.has(element);
        });
      }, `deepEquals(Set[${iterableToString(expectation)}])`);
    };
    createMatcher.set.contains = function setContains(expectation) {
      return createMatcher(function(actual) {
        return typeOf(actual) === "set" && every(expectation, function(element) {
          return actual.has(element);
        });
      }, `contains(Set[${iterableToString(expectation)}])`);
    };
    createMatcher.bool = createMatcher.typeOf("boolean");
    createMatcher.number = createMatcher.typeOf("number");
    createMatcher.string = createMatcher.typeOf("string");
    createMatcher.object = createMatcher.typeOf("object");
    createMatcher.func = createMatcher.typeOf("function");
    createMatcher.regexp = createMatcher.typeOf("regexp");
    createMatcher.date = createMatcher.typeOf("date");
    createMatcher.symbol = createMatcher.typeOf("symbol");
    module.exports = createMatcher;
  });

  // node_modules/@sinonjs/samsam/lib/match.js
  var require_match = __commonJS((exports, module) => {
    "use strict";
    var valueToString = require_lib().valueToString;
    var indexOf = require_lib().prototypes.string.indexOf;
    var forEach = require_lib().prototypes.array.forEach;
    var type = require_type_detect();
    var engineCanCompareMaps = typeof Array.from === "function";
    var deepEqual = require_deep_equal().use(match);
    var isArrayType = require_is_array_type();
    var isSubset = require_is_subset();
    var createMatcher = require_create_matcher();
    function arrayContains(array, subset, compare) {
      if (subset.length === 0) {
        return true;
      }
      var i, l, j, k;
      for (i = 0, l = array.length; i < l; ++i) {
        if (compare(array[i], subset[0])) {
          for (j = 0, k = subset.length; j < k; ++j) {
            if (i + j >= l) {
              return false;
            }
            if (!compare(array[i + j], subset[j])) {
              return false;
            }
          }
          return true;
        }
      }
      return false;
    }
    function match(object, matcherOrValue) {
      if (matcherOrValue && typeof matcherOrValue.test === "function") {
        return matcherOrValue.test(object);
      }
      switch (type(matcherOrValue)) {
        case "bigint":
        case "boolean":
        case "number":
        case "symbol":
          return matcherOrValue === object;
        case "function":
          return matcherOrValue(object) === true;
        case "string":
          var notNull = typeof object === "string" || Boolean(object);
          return notNull && indexOf(valueToString(object).toLowerCase(), matcherOrValue.toLowerCase()) >= 0;
        case "null":
          return object === null;
        case "undefined":
          return typeof object === "undefined";
        case "Date":
          if (type(object) === "Date") {
            return object.getTime() === matcherOrValue.getTime();
          }
          break;
        case "Array":
        case "Int8Array":
        case "Uint8Array":
        case "Uint8ClampedArray":
        case "Int16Array":
        case "Uint16Array":
        case "Int32Array":
        case "Uint32Array":
        case "Float32Array":
        case "Float64Array":
          return isArrayType(matcherOrValue) && arrayContains(object, matcherOrValue, match);
        case "Map":
          if (!engineCanCompareMaps) {
            throw new Error("The JavaScript engine does not support Array.from and cannot reliably do value comparison of Map instances");
          }
          return type(object) === "Map" && arrayContains(Array.from(object), Array.from(matcherOrValue), match);
        default:
          break;
      }
      switch (type(object)) {
        case "null":
          return false;
        case "Set":
          return isSubset(matcherOrValue, object, match);
        default:
          break;
      }
      if (matcherOrValue && typeof matcherOrValue === "object") {
        if (matcherOrValue === object) {
          return true;
        }
        if (typeof object !== "object") {
          return false;
        }
        var prop;
        for (prop in matcherOrValue) {
          var value = object[prop];
          if (typeof value === "undefined" && typeof object.getAttribute === "function") {
            value = object.getAttribute(prop);
          }
          if (matcherOrValue[prop] === null || typeof matcherOrValue[prop] === "undefined") {
            if (value !== matcherOrValue[prop]) {
              return false;
            }
          } else if (typeof value === "undefined" || !deepEqual(value, matcherOrValue[prop])) {
            return false;
          }
        }
        return true;
      }
      throw new Error("Matcher was an unknown or unsupported type");
    }
    forEach(Object.keys(createMatcher), function(key) {
      match[key] = createMatcher[key];
    });
    module.exports = match;
  });

  // node_modules/@sinonjs/samsam/lib/samsam.js
  var require_samsam = __commonJS((exports, module) => {
    "use strict";
    var identical = require_identical();
    var isArguments = require_is_arguments2();
    var isElement = require_is_element();
    var isNegZero = require_is_neg_zero();
    var isSet = require_is_set();
    var isMap = require_is_map();
    var match = require_match();
    var deepEqualCyclic = require_deep_equal().use(match);
    var createMatcher = require_create_matcher();
    module.exports = {
      createMatcher,
      deepEqual: deepEqualCyclic,
      identical,
      isArguments,
      isElement,
      isMap,
      isNegZero,
      isSet,
      match
    };
  });

  // lib/assertions/class-name.js
  var require_class_name2 = __commonJS((exports, module) => {
    "use strict";
    var noClassNameMessage = "${customMessage}Expected object to have className property";
    module.exports = function(referee) {
      referee.add("className", {
        assert: function(element, name) {
          if (typeof element.className === "undefined") {
            return this.fail(noClassNameMessage);
          }
          var expected = typeof name === "string" ? name.split(" ") : name;
          var actual = element.className.split(" ");
          var i, l;
          for (i = 0, l = expected.length; i < l; i++) {
            if (!actual.includes(expected[i])) {
              return false;
            }
          }
          return true;
        },
        assertMessage: "${customMessage}Expected object's className to include ${expected} but was ${actual}",
        refuteMessage: "${customMessage}Expected object's className not to include ${expected}",
        expectation: "toHaveClassName",
        values: function(element, className, message) {
          return {
            actualElement: element,
            actual: element.className,
            expected: className,
            customMessage: message
          };
        }
      });
    };
  });

  // lib/actual-and-expected-message-values.js
  var require_actual_and_expected_message_values = __commonJS((exports, module) => {
    "use strict";
    function actualAndExpectedMessageValues(actual, expected, message) {
      return {
        actual,
        expected,
        customMessage: message
      };
    }
    module.exports = actualAndExpectedMessageValues;
  });

  // lib/assertions/contains.js
  var require_contains2 = __commonJS((exports, module) => {
    "use strict";
    var actualAndExpectedMessageValues = require_actual_and_expected_message_values();
    module.exports = function(referee) {
      referee.add("contains", {
        assert: function(haystack, needle) {
          return haystack.includes(needle);
        },
        assertMessage: "${customMessage}Expected ${actual} to contain ${expected}",
        refuteMessage: "${customMessage}Expected ${actual} not to contain ${expected}",
        expectation: "toContain",
        values: actualAndExpectedMessageValues
      });
    };
  });

  // lib/assertions/equals.js
  var require_equals = __commonJS((exports, module) => {
    "use strict";
    var samsam = require_samsam();
    module.exports = function(referee) {
      referee.add("equals", {
        assert: function(actual, expected) {
          if (typeof expected === "undefined") {
            return this.fail("Expectation for equals should not be undefined. Use assert.isUndefined instead.");
          }
          return samsam.deepEqual(actual, expected);
        },
        assertMessage: "${customMessage}${actual} expected to be equal to ${expected}",
        refuteMessage: "${customMessage}${actual} expected not to be equal to ${expected}",
        expectation: "toEqual",
        values: function(actual, expected, message) {
          return {
            actual,
            expected,
            customMessage: message
          };
        }
      });
      referee.assert.equals.multiLineStringHeading = "${customMessage}Expected multi-line strings to be equal:\n";
    };
  });

  // lib/capture-exception.js
  var require_capture_exception = __commonJS((exports, module) => {
    "use strict";
    function captureException(callback) {
      try {
        callback();
      } catch (e) {
        return e;
      }
      return null;
    }
    module.exports = captureException;
  });

  // lib/assertions/exception.js
  var require_exception = __commonJS((exports, module) => {
    "use strict";
    var samsam = require_samsam();
    var hasOwnProperty2 = require_lib().prototypes.object.hasOwnProperty;
    var captureException = require_capture_exception();
    var typeNoExceptionMessage = "${customMessage}Expected ${expected} but no exception was thrown";
    var typeFailMessage = "${customMessage}Expected ${expected} but threw ${actualExceptionType} (${actualExceptionMessage})\n${actualExceptionStack}";
    var matchFailMessage = "${customMessage}Expected thrown ${actualExceptionType} (${actualExceptionMessage}) to pass matcher function";
    module.exports = function(referee) {
      referee.captureException = captureException;
      referee.add("exception", {
        assert: function(callback) {
          var matcher = arguments[1];
          var customMessage = arguments[2];
          if (typeof matcher === "string") {
            customMessage = matcher;
            matcher = void 0;
          }
          this.expected = matcher;
          this.customMessage = customMessage;
          var err = captureException(callback);
          if (err) {
            this.actualExceptionType = err.name;
            this.actualExceptionMessage = err.message;
            this.actualExceptionStack = err.stack;
          }
          if (!err) {
            if (typeof matcher === "object") {
              return this.fail(typeNoExceptionMessage);
            }
            return this.fail("message");
          }
          if (typeof matcher === "object" && !samsam.match(err, matcher)) {
            var matches = false;
            var prop;
            for (prop in matcher) {
              if (hasOwnProperty2(matcher, prop)) {
                if (!samsam.match(err[prop], matcher[prop])) {
                  return this.fail(typeFailMessage);
                }
                matches = true;
              }
            }
            return matches;
          }
          if (typeof matcher === "function" && matcher(err) !== true) {
            return this.fail(matchFailMessage);
          }
          return true;
        },
        refute: function(callback) {
          var err = captureException(callback);
          if (err) {
            this.customMessage = arguments[1];
            this.actualExceptionType = err.name;
            this.actualExceptionMessage = err.message;
            return false;
          }
          return true;
        },
        expectation: "toThrow",
        assertMessage: "${customMessage}Expected exception",
        refuteMessage: "${customMessage}Expected not to throw but threw ${actualExceptionType} (${actualExceptionMessage})"
      });
    };
  });

  // lib/assertions/greater.js
  var require_greater = __commonJS((exports, module) => {
    "use strict";
    var actualAndExpectedMessageValues = require_actual_and_expected_message_values();
    module.exports = function(referee) {
      referee.add("greater", {
        assert: function(actual, expected) {
          return actual > expected;
        },
        assertMessage: "${customMessage}Expected ${actual} to be greater than ${expected}",
        refuteMessage: "${customMessage}Expected ${actual} to be less than or equal to ${expected}",
        expectation: "toBeGreaterThan",
        values: actualAndExpectedMessageValues
      });
    };
  });

  // lib/assertions/has-arity.js
  var require_has_arity = __commonJS((exports, module) => {
    "use strict";
    var actualAndExpectedMessageValues = require_actual_and_expected_message_values();
    function addHasArity(referee) {
      referee.add("hasArity", {
        assert: function assert(actual, expected) {
          if (typeof actual !== "function") {
            throw new TypeError('hasArity expects "actual" argument to be a Function');
          }
          if (typeof expected !== "number" || expected < 0) {
            throw new TypeError('hasArity expected "expected" argument to be a non-negative Number');
          }
          this.arity = actual.length;
          this.name = actual.name;
          return this.arity === expected;
        },
        assertMessage: "Expected ${name} to have arity of ${1} but was ${arity}",
        refuteMessage: "Expected ${name} to not have arity of ${1}",
        expectation: "toHaveArity",
        values: actualAndExpectedMessageValues
      });
    }
    module.exports = addHasArity;
  });

  // lib/assertions/has-prototype.js
  var require_has_prototype = __commonJS((exports, module) => {
    "use strict";
    var actualAndExpectedMessageValues = require_actual_and_expected_message_values();
    module.exports = function(referee) {
      referee.add("hasPrototype", {
        assert: function(actual, protoObj) {
          return protoObj.isPrototypeOf(actual);
        },
        assertMessage: "${customMessage}Expected ${actual} to have ${expected} on its prototype chain",
        refuteMessage: "${customMessage}Expected ${actual} not to have ${expected} on its prototype chain",
        expectation: "toHavePrototype",
        values: actualAndExpectedMessageValues
      });
    };
  });

  // lib/actual-message-values.js
  var require_actual_message_values = __commonJS((exports, module) => {
    "use strict";
    function actualMessageValues(actual, message) {
      return {
        actual,
        customMessage: message
      };
    }
    module.exports = actualMessageValues;
  });

  // lib/assertions/is-array.js
  var require_is_array = __commonJS((exports, module) => {
    "use strict";
    var actualMessageValues = require_actual_message_values();
    module.exports = function(referee) {
      referee.add("isArray", {
        assert: function(actual) {
          return Array.isArray(actual);
        },
        assertMessage: "${customMessage}Expected ${actual} to be array",
        refuteMessage: "${customMessage}Expected ${actual} not to be array",
        expectation: "toBeArray",
        values: actualMessageValues
      });
    };
  });

  // lib/assertions/is-array-buffer.js
  var require_is_array_buffer = __commonJS((exports, module) => {
    "use strict";
    var actualMessageValues = require_actual_message_values();
    var toString = require_lib().prototypes.object.toString;
    module.exports = function(referee) {
      referee.add("isArrayBuffer", {
        assert: function(actual) {
          return toString(actual) === "[object ArrayBuffer]";
        },
        assertMessage: "${customMessage}Expected ${actual} to be an ArrayBuffer",
        refuteMessage: "${customMessage}Expected ${actual} not to be an ArrayBuffer",
        expectation: "toBeArrayBuffer",
        values: actualMessageValues
      });
    };
  });

  // node_modules/lodash.isarguments/index.js
  var require_lodash2 = __commonJS((exports, module) => {
    var MAX_SAFE_INTEGER = 9007199254740991;
    var argsTag = "[object Arguments]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var objectProto = Object.prototype;
    var hasOwnProperty2 = objectProto.hasOwnProperty;
    var objectToString = objectProto.toString;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    function isArguments(value) {
      return isArrayLikeObject(value) && hasOwnProperty2.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
    }
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    function isFunction(value) {
      var tag = isObject(value) ? objectToString.call(value) : "";
      return tag == funcTag || tag == genTag;
    }
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    module.exports = isArguments;
  });

  // lib/assertions/is-array-like.js
  var require_is_array_like = __commonJS((exports, module) => {
    "use strict";
    var isArguments = require_lodash2();
    var actualMessageValues = require_actual_message_values();
    module.exports = function(referee) {
      function isArrayLike(object) {
        return Array.isArray(object) || Boolean(object) && typeof object.length === "number" && typeof object.splice === "function" || isArguments(object);
      }
      referee.add("isArrayLike", {
        assert: function(actual) {
          return isArrayLike(actual);
        },
        assertMessage: "${customMessage}Expected ${actual} to be array like",
        refuteMessage: "${customMessage}Expected ${actual} not to be array like",
        expectation: "toBeArrayLike",
        values: actualMessageValues
      });
    };
  });

  // lib/assertions/is-boolean.js
  var require_is_boolean = __commonJS((exports, module) => {
    "use strict";
    module.exports = function(referee) {
      referee.add("isBoolean", {
        assert: function(actual) {
          return typeof actual === "boolean";
        },
        assertMessage: "${customMessage}Expected ${value} (${actual}) to be boolean",
        refuteMessage: "${customMessage}Expected ${value} not to be boolean",
        expectation: "toBeBoolean",
        values: function(actual, message) {
          return {
            value: actual,
            actual: typeof actual,
            expected: "boolean",
            customMessage: message
          };
        }
      });
    };
  });

  // lib/assertions/is-data-view.js
  var require_is_data_view = __commonJS((exports, module) => {
    "use strict";
    var actualMessageValues = require_actual_message_values();
    var toString = require_lib().prototypes.object.toString;
    module.exports = function(referee) {
      referee.add("isDataView", {
        assert: function(actual) {
          return toString(actual) === "[object DataView]";
        },
        assertMessage: "${customMessage}Expected ${actual} to be a DataView",
        refuteMessage: "${customMessage}Expected ${actual} not to be a DataView",
        expectation: "toBeDataView",
        values: actualMessageValues
      });
    };
  });

  // lib/assertions/is-date.js
  var require_is_date2 = __commonJS((exports, module) => {
    "use strict";
    var actualMessageValues = require_actual_message_values();
    module.exports = function(referee) {
      referee.add("isDate", {
        assert: function(actual) {
          return actual instanceof Date;
        },
        assertMessage: "${customMessage}Expected ${actual} to be a Date",
        refuteMessage: "${customMessage}Expected ${actual} not to be a Date",
        expectation: "toBeDate",
        values: actualMessageValues
      });
    };
  });

  // lib/assertions/is-error.js
  var require_is_error = __commonJS((exports, module) => {
    "use strict";
    var actualMessageValues = require_actual_message_values();
    module.exports = function(referee) {
      referee.add("isError", {
        assert: function(actual) {
          return actual instanceof Error;
        },
        assertMessage: "${customMessage}Expected ${actual} to be an Error",
        refuteMessage: "${customMessage}Expected ${actual} not to be an Error",
        expectation: "toBeError",
        values: actualMessageValues
      });
    };
  });

  // lib/assertions/is-eval-error.js
  var require_is_eval_error = __commonJS((exports, module) => {
    "use strict";
    var actualMessageValues = require_actual_message_values();
    module.exports = function(referee) {
      referee.add("isEvalError", {
        assert: function(actual) {
          return actual instanceof EvalError;
        },
        assertMessage: "${customMessage}Expected ${actual} to be an EvalError",
        refuteMessage: "${customMessage}Expected ${actual} not to be an EvalError",
        expectation: "toBeEvalError",
        values: actualMessageValues
      });
    };
  });

  // lib/assertions/is-false.js
  var require_is_false = __commonJS((exports, module) => {
    "use strict";
    var actualMessageValues = require_actual_message_values();
    module.exports = function(referee) {
      referee.add("isFalse", {
        assert: function(actual) {
          return actual === false;
        },
        assertMessage: "${customMessage}Expected ${actual} to be false",
        refuteMessage: "${customMessage}Expected ${actual} to not be false",
        expectation: "toBeFalse",
        values: actualMessageValues
      });
    };
  });

  // lib/assertions/is-float-32-array.js
  var require_is_float_32_array = __commonJS((exports, module) => {
    "use strict";
    var actualMessageValues = require_actual_message_values();
    module.exports = function(referee) {
      referee.add("isFloat32Array", {
        assert: function(actual) {
          return actual instanceof Float32Array;
        },
        assertMessage: "${customMessage}Expected ${actual} to be a Float32Array",
        refuteMessage: "${customMessage}Expected ${actual} not to be a Float32Array",
        expectation: "toBeFloat32Array",
        values: actualMessageValues
      });
    };
  });

  // lib/assertions/is-float-64-array.js
  var require_is_float_64_array = __commonJS((exports, module) => {
    "use strict";
    var actualMessageValues = require_actual_message_values();
    module.exports = function(referee) {
      referee.add("isFloat64Array", {
        assert: function(actual) {
          return actual instanceof Float64Array;
        },
        assertMessage: "${customMessage}Expected ${actual} to be a Float64Array",
        refuteMessage: "${customMessage}Expected ${actual} not to be a Float64Array",
        expectation: "toBeFloat64Array",
        values: actualMessageValues
      });
    };
  });

  // lib/assertions/is-function.js
  var require_is_function = __commonJS((exports, module) => {
    "use strict";
    module.exports = function(referee) {
      referee.add("isFunction", {
        assert: function(actual) {
          return typeof actual === "function";
        },
        assertMessage: "${customMessage}${value} (${actual}) expected to be function",
        refuteMessage: "${customMessage}${value} expected not to be function",
        expectation: "toBeFunction",
        values: function(actual, message) {
          return {
            value: String(actual).replace("function(", "function (").replace("\n", ""),
            actual: typeof actual,
            expected: "function",
            customMessage: message
          };
        }
      });
    };
  });

  // lib/assertions/is-infinity.js
  var require_is_infinity = __commonJS((exports, module) => {
    "use strict";
    module.exports = function(referee) {
      referee.add("isInfinity", {
        assert: function(actual) {
          return actual === Infinity;
        },
        assertMessage: "${customMessage}Expected ${actual} to be Infinity",
        refuteMessage: "${customMessage}Expected ${actual} not to be Infinity",
        expectation: "toBeInfinity",
        values: function(actual, message) {
          return {
            actual,
            expected: Infinity,
            customMessage: message
          };
        }
      });
    };
  });

  // lib/assertions/is-int-8-array.js
  var require_is_int_8_array = __commonJS((exports, module) => {
    "use strict";
    var actualMessageValues = require_actual_message_values();
    module.exports = function(referee) {
      referee.add("isInt8Array", {
        assert: function(actual) {
          return actual instanceof Int8Array;
        },
        assertMessage: "${customMessage}Expected ${actual} to be an Int8Array",
        refuteMessage: "${customMessage}Expected ${actual} not to be an Int8Array",
        expectation: "toBeInd8Array",
        values: actualMessageValues
      });
    };
  });

  // lib/assertions/is-int-16-array.js
  var require_is_int_16_array = __commonJS((exports, module) => {
    "use strict";
    var actualMessageValues = require_actual_message_values();
    module.exports = function(referee) {
      referee.add("isInt16Array", {
        assert: function(actual) {
          return actual instanceof Int16Array;
        },
        assertMessage: "${customMessage}Expected ${actual} to be an Int16Array",
        refuteMessage: "${customMessage}Expected ${actual} not to be an Int16Array",
        expectation: "toBeInt16Array",
        values: actualMessageValues
      });
    };
  });

  // lib/assertions/is-int-32-array.js
  var require_is_int_32_array = __commonJS((exports, module) => {
    "use strict";
    var actualMessageValues = require_actual_message_values();
    module.exports = function(referee) {
      referee.add("isInt32Array", {
        assert: function(actual) {
          return actual instanceof Int32Array;
        },
        assertMessage: "${customMessage}Expected ${actual} to be an Int32Array",
        refuteMessage: "${customMessage}Expected ${actual} not to be an Int32Array",
        expectation: "toBeInt32Array",
        values: actualMessageValues
      });
    };
  });

  // lib/assertions/is-intl-collator.js
  var require_is_intl_collator = __commonJS((exports, module) => {
    "use strict";
    var actualMessageValues = require_actual_message_values();
    module.exports = function(referee) {
      referee.add("isIntlCollator", {
        assert: function(actual) {
          return actual instanceof Intl.Collator;
        },
        assertMessage: "${customMessage}Expected ${actual} to be an Intl.Collator",
        refuteMessage: "${customMessage}Expected ${actual} not to be an Intl.Collator",
        expectation: "toBeIntlCollator",
        values: actualMessageValues
      });
    };
  });

  // lib/assertions/is-intl-date-time-format.js
  var require_is_intl_date_time_format = __commonJS((exports, module) => {
    "use strict";
    var actualMessageValues = require_actual_message_values();
    module.exports = function(referee) {
      referee.add("isIntlDateTimeFormat", {
        assert: function(actual) {
          return actual instanceof Intl.DateTimeFormat;
        },
        assertMessage: "${customMessage}Expected ${actual} to be an Intl.DateTimeFormat",
        refuteMessage: "${customMessage}Expected ${actual} not to be an Intl.DateTimeFormat",
        expectation: "toBeIntlDateTimeFormat",
        values: actualMessageValues
      });
    };
  });

  // lib/assertions/is-intl-number-format.js
  var require_is_intl_number_format = __commonJS((exports, module) => {
    "use strict";
    var actualMessageValues = require_actual_message_values();
    module.exports = function(referee) {
      referee.add("isIntlNumberFormat", {
        assert: function(actual) {
          return actual instanceof Intl.NumberFormat;
        },
        assertMessage: "${customMessage}Expected ${actual} to be an Intl.NumberFormat",
        refuteMessage: "${customMessage}Expected ${actual} not to be an Intl.NumberFormat",
        expectation: "toBeIntlNumberFormat",
        values: actualMessageValues
      });
    };
  });

  // lib/assertions/is-map.js
  var require_is_map2 = __commonJS((exports, module) => {
    "use strict";
    var actualMessageValues = require_actual_message_values();
    module.exports = function(referee) {
      referee.add("isMap", {
        assert: function(actual) {
          return actual instanceof Map;
        },
        assertMessage: "${customMessage}Expected ${actual} to be a Map",
        refuteMessage: "${customMessage}Expected ${actual} not to be a Map",
        expectation: "toBeMap",
        values: actualMessageValues
      });
    };
  });

  // lib/assertions/is-nan.js
  var require_is_nan2 = __commonJS((exports, module) => {
    "use strict";
    module.exports = function(referee) {
      referee.add("isNaN", {
        assert: function(actual) {
          return typeof actual === "number" && isNaN(actual);
        },
        assertMessage: "${customMessage}Expected ${actual} to be NaN",
        refuteMessage: "${customMessage}Expected not to be NaN",
        expectation: "toBeNaN",
        values: function(actual, message) {
          return {
            actual,
            expected: "NaN",
            customMessage: message
          };
        }
      });
    };
  });

  // lib/assertions/is-null.js
  var require_is_null = __commonJS((exports, module) => {
    "use strict";
    module.exports = function(referee) {
      referee.add("isNull", {
        assert: function(actual) {
          return actual === null;
        },
        assertMessage: "${customMessage}Expected ${actual} to be null",
        refuteMessage: "${customMessage}Expected not to be null",
        expectation: "toBeNull",
        values: function(actual, message) {
          return {
            actual,
            expected: null,
            customMessage: message
          };
        }
      });
    };
  });

  // lib/assertions/is-negative-infinity.js
  var require_is_negative_infinity = __commonJS((exports, module) => {
    "use strict";
    module.exports = function(referee) {
      referee.add("isNegativeInfinity", {
        assert: function(actual) {
          return actual === -Infinity;
        },
        assertMessage: "${customMessage}Expected ${actual} to be -Infinity",
        refuteMessage: "${customMessage}Expected ${actual} not to be -Infinity",
        expectation: "toBeNegativeInfinity",
        values: function(actual, message) {
          return {
            actual,
            expected: -Infinity,
            customMessage: message
          };
        }
      });
    };
  });

  // lib/assertions/is-number.js
  var require_is_number = __commonJS((exports, module) => {
    "use strict";
    module.exports = function(referee) {
      referee.add("isNumber", {
        assert: function(actual) {
          return typeof actual === "number" && !isNaN(actual);
        },
        assertMessage: "${customMessage}Expected ${value} (${actual}) to be a non-NaN number",
        refuteMessage: "${customMessage}Expected ${value} to be NaN or a non-number value",
        expectation: "toBeNumber",
        values: function(actual, message) {
          return {
            value: actual,
            actual: typeof actual,
            expected: "number",
            customMessage: message
          };
        }
      });
    };
  });

  // lib/assertions/is-object.js
  var require_is_object2 = __commonJS((exports, module) => {
    "use strict";
    module.exports = function(referee) {
      referee.add("isObject", {
        assert: function(actual) {
          return typeof actual === "object" && Boolean(actual);
        },
        assertMessage: "${customMessage}${value} (${actual}) expected to be object and not null",
        refuteMessage: "${customMessage}${value} expected to be null or not an object",
        expectation: "toBeObject",
        values: function(actual, message) {
          return {
            value: actual,
            actual: typeof actual,
            expected: "object",
            customMessage: message
          };
        }
      });
    };
  });

  // lib/assertions/is-promise.js
  var require_is_promise = __commonJS((exports, module) => {
    "use strict";
    var actualMessageValues = require_actual_message_values();
    module.exports = function(referee) {
      referee.add("isPromise", {
        assert: function(actual) {
          return actual instanceof Promise;
        },
        assertMessage: "${customMessage}Expected ${actual} to be a Promise",
        refuteMessage: "${customMessage}Expected ${actual} not to be a Promise",
        expectation: "toBePromise",
        values: actualMessageValues
      });
    };
  });

  // lib/assertions/is-range-error.js
  var require_is_range_error = __commonJS((exports, module) => {
    "use strict";
    var actualMessageValues = require_actual_message_values();
    module.exports = function(referee) {
      referee.add("isRangeError", {
        assert: function(actual) {
          return actual instanceof RangeError;
        },
        assertMessage: "${customMessage}Expected ${actual} to be a RangeError",
        refuteMessage: "${customMessage}Expected ${actual} not to be a RangeError",
        expectation: "toBeRangeError",
        values: actualMessageValues
      });
    };
  });

  // lib/assertions/is-reference-error.js
  var require_is_reference_error = __commonJS((exports, module) => {
    "use strict";
    var actualMessageValues = require_actual_message_values();
    module.exports = function(referee) {
      referee.add("isReferenceError", {
        assert: function(actual) {
          return actual instanceof ReferenceError;
        },
        assertMessage: "${customMessage}Expected ${actual} to be a ReferenceError",
        refuteMessage: "${customMessage}Expected ${actual} not to be a ReferenceError",
        expectation: "toBeReferenceError",
        values: actualMessageValues
      });
    };
  });

  // lib/assertions/is-reg-exp.js
  var require_is_reg_exp = __commonJS((exports, module) => {
    "use strict";
    var actualMessageValues = require_actual_message_values();
    module.exports = function(referee) {
      referee.add("isRegExp", {
        assert: function(actual) {
          return actual instanceof RegExp;
        },
        assertMessage: "${customMessage}Expected ${actual} to be a RegExp",
        refuteMessage: "${customMessage}Expected ${actual} not to be a RegExp",
        expectation: "toBeRegExp",
        values: actualMessageValues
      });
    };
  });

  // lib/assertions/is-set.js
  var require_is_set2 = __commonJS((exports, module) => {
    "use strict";
    var actualMessageValues = require_actual_message_values();
    module.exports = function(referee) {
      referee.add("isSet", {
        assert: function(actual) {
          return actual instanceof Set;
        },
        assertMessage: "${customMessage}Expected ${actual} to be a Set",
        refuteMessage: "${customMessage}Expected ${actual} not to be a Set",
        expectation: "toBeSet",
        values: actualMessageValues
      });
    };
  });

  // lib/assertions/is-string.js
  var require_is_string = __commonJS((exports, module) => {
    "use strict";
    module.exports = function(referee) {
      referee.add("isString", {
        assert: function(actual) {
          return typeof actual === "string";
        },
        assertMessage: "${customMessage}Expected ${value} (${actual}) to be string",
        refuteMessage: "${customMessage}Expected ${value} not to be string",
        expectation: "toBeString",
        values: function(actual, message) {
          return {
            value: actual,
            actual: typeof actual,
            expected: "string",
            customMessage: message
          };
        }
      });
    };
  });

  // lib/assertions/is-symbol.js
  var require_is_symbol = __commonJS((exports, module) => {
    "use strict";
    module.exports = function(referee) {
      referee.add("isSymbol", {
        assert: function(actual) {
          return typeof actual === "symbol";
        },
        assertMessage: "${customMessage}Expected ${actual} to be a Symbol",
        refuteMessage: "${customMessage}Expected ${actual} not to be a Symbol",
        expectation: "toBeSymbol",
        values: function(actual, message) {
          return {
            actual,
            expected: "symbol",
            customMessage: message
          };
        }
      });
    };
  });

  // lib/assertions/is-syntax-error.js
  var require_is_syntax_error = __commonJS((exports, module) => {
    "use strict";
    var actualMessageValues = require_actual_message_values();
    module.exports = function(referee) {
      referee.add("isSyntaxError", {
        assert: function(actual) {
          return actual instanceof SyntaxError;
        },
        assertMessage: "${customMessage}Expected ${actual} to be a SyntaxError",
        refuteMessage: "${customMessage}Expected ${actual} not to be a SyntaxError",
        expectation: "toBeSyntaxError",
        values: actualMessageValues
      });
    };
  });

  // lib/assertions/is-true.js
  var require_is_true = __commonJS((exports, module) => {
    "use strict";
    var actualMessageValues = require_actual_message_values();
    module.exports = function(referee) {
      referee.add("isTrue", {
        assert: function(actual) {
          return actual === true;
        },
        assertMessage: "${customMessage}Expected ${actual} to be true",
        refuteMessage: "${customMessage}Expected ${actual} to not be true",
        expectation: "toBeTrue",
        values: actualMessageValues
      });
    };
  });

  // lib/assertions/is-type-error.js
  var require_is_type_error = __commonJS((exports, module) => {
    "use strict";
    var actualMessageValues = require_actual_message_values();
    module.exports = function(referee) {
      referee.add("isTypeError", {
        assert: function(actual) {
          return actual instanceof TypeError;
        },
        assertMessage: "${customMessage}Expected ${actual} to be a TypeError",
        refuteMessage: "${customMessage}Expected ${actual} not to be a TypeError",
        expectation: "toBeTypeError",
        values: actualMessageValues
      });
    };
  });

  // lib/actual-and-type-of-message-values.js
  var require_actual_and_type_of_message_values = __commonJS((exports, module) => {
    "use strict";
    function actualAndTypeOfMessageValues(actual, message) {
      return {
        actual,
        actualType: typeof actual,
        customMessage: message
      };
    }
    module.exports = actualAndTypeOfMessageValues;
  });

  // lib/assertions/is-undefined.js
  var require_is_undefined = __commonJS((exports, module) => {
    "use strict";
    var actualAndTypeOfMessageValues = require_actual_and_type_of_message_values();
    module.exports = function(referee) {
      referee.add("isUndefined", {
        assert: function(actual) {
          return typeof actual === "undefined";
        },
        assertMessage: "${customMessage}Expected ${actual} (${actualType}) to be undefined",
        refuteMessage: "${customMessage}Expected ${actual} (${actualType}) not to be undefined",
        expectation: "toBeUndefined",
        values: actualAndTypeOfMessageValues
      });
    };
  });

  // lib/assertions/is-uri-error.js
  var require_is_uri_error = __commonJS((exports, module) => {
    "use strict";
    var actualMessageValues = require_actual_message_values();
    module.exports = function(referee) {
      referee.add("isURIError", {
        assert: function(actual) {
          return actual instanceof URIError;
        },
        assertMessage: "${customMessage}Expected ${actual} to be a URIError",
        refuteMessage: "${customMessage}Expected ${actual} not to be a URIError",
        expectation: "toBeURIError",
        values: actualMessageValues
      });
    };
  });

  // lib/assertions/is-u-int-16-array.js
  var require_is_u_int_16_array = __commonJS((exports, module) => {
    "use strict";
    var actualMessageValues = require_actual_message_values();
    module.exports = function(referee) {
      referee.add("isUint16Array", {
        assert: function(actual) {
          return actual instanceof Uint16Array;
        },
        assertMessage: "${customMessage}Expected ${actual} to be a Uint16Array",
        refuteMessage: "${customMessage}Expected ${actual} not to be a Uint16Array",
        expectation: "toBeUint16Array",
        values: actualMessageValues
      });
    };
  });

  // lib/assertions/is-u-int-32-array.js
  var require_is_u_int_32_array = __commonJS((exports, module) => {
    "use strict";
    var actualMessageValues = require_actual_message_values();
    module.exports = function(referee) {
      referee.add("isUint32Array", {
        assert: function(actual) {
          return actual instanceof Uint32Array;
        },
        assertMessage: "${customMessage}Expected ${actual} to be a Uint32Array",
        refuteMessage: "${customMessage}Expected ${actual} not to be a Uint32Array",
        expectation: "toBeUint32Array",
        values: actualMessageValues
      });
    };
  });

  // lib/assertions/is-u-int-8-array.js
  var require_is_u_int_8_array = __commonJS((exports, module) => {
    "use strict";
    var actualMessageValues = require_actual_message_values();
    module.exports = function(referee) {
      referee.add("isUint8Array", {
        assert: function(actual) {
          return actual instanceof Uint8Array;
        },
        assertMessage: "${customMessage}Expected ${actual} to be a Uint8Array",
        refuteMessage: "${customMessage}Expected ${actual} not to be a Uint8Array",
        expectation: "toBeUint8Array",
        values: actualMessageValues
      });
    };
  });

  // lib/assertions/is-u-int-8-clamped-array.js
  var require_is_u_int_8_clamped_array = __commonJS((exports, module) => {
    "use strict";
    var actualMessageValues = require_actual_message_values();
    module.exports = function(referee) {
      referee.add("isUint8ClampedArray", {
        assert: function(actual) {
          return actual instanceof Uint8ClampedArray;
        },
        assertMessage: "${customMessage}Expected ${actual} to be a Uint8ClampedArray",
        refuteMessage: "${customMessage}Expected ${actual} not to be a Uint8ClampedArray",
        expectation: "toBeUint8ClampedArray",
        values: actualMessageValues
      });
    };
  });

  // lib/assertions/is-weak-map.js
  var require_is_weak_map = __commonJS((exports, module) => {
    "use strict";
    var actualMessageValues = require_actual_message_values();
    module.exports = function(referee) {
      referee.add("isWeakMap", {
        assert: function(actual) {
          return actual instanceof WeakMap;
        },
        assertMessage: "${customMessage}Expected ${actual} to be a WeakMap",
        refuteMessage: "${customMessage}Expected ${actual} not to be a WeakMap",
        expectation: "toBeWeakMap",
        values: actualMessageValues
      });
    };
  });

  // lib/assertions/is-weak-set.js
  var require_is_weak_set = __commonJS((exports, module) => {
    "use strict";
    var actualMessageValues = require_actual_message_values();
    module.exports = function(referee) {
      referee.add("isWeakSet", {
        assert: function(actual) {
          return actual instanceof WeakSet;
        },
        assertMessage: "${customMessage}Expected ${actual} to be a WeakSet",
        refuteMessage: "${customMessage}Expected ${actual} not to be a WeakSet",
        expectation: "toBeWeakSet",
        values: actualMessageValues
      });
    };
  });

  // lib/assertions/keys.js
  var require_keys2 = __commonJS((exports, module) => {
    "use strict";
    module.exports = function(referee) {
      function exactKeys(object, keys) {
        var keyMap = {};
        var keyCnt = 0;
        for (var i = 0; i < keys.length; i++) {
          keyMap[keys[i]] = true;
          keyCnt += 1;
        }
        for (var key in object) {
          if (object.hasOwnProperty(key)) {
            if (!keyMap[key]) {
              return false;
            }
            keyCnt -= 1;
          }
        }
        return keyCnt === 0;
      }
      referee.add("keys", {
        assert: function(actual, keys) {
          return exactKeys(actual, keys);
        },
        assertMessage: "${customMessage}Expected ${actualObject} to have exact keys ${expected}",
        refuteMessage: "${customMessage}Expected not to have exact keys ${expected}",
        expectation: "toHaveKeys",
        values: function(actual, keys, message) {
          return {
            actualObject: actual,
            actual: Object.keys(actual),
            expected: keys,
            customMessage: message
          };
        }
      });
    };
  });

  // lib/assertions/less.js
  var require_less = __commonJS((exports, module) => {
    "use strict";
    var actualAndExpectedMessageValues = require_actual_and_expected_message_values();
    module.exports = function(referee) {
      referee.add("less", {
        assert: function(actual, expected) {
          return actual < expected;
        },
        assertMessage: "${customMessage}Expected ${actual} to be less than ${expected}",
        refuteMessage: "${customMessage}Expected ${actual} to be greater than or equal to ${expected}",
        expectation: "toBeLessThan",
        values: actualAndExpectedMessageValues
      });
    };
  });

  // lib/actual-for-match.js
  var require_actual_for_match = __commonJS((exports, module) => {
    "use strict";
    var toString = require_lib().prototypes.object.toString;
    function actualForMatch(actual, match) {
      if (toString(actual) === "[object Object]" && toString(match) === "[object Object]") {
        var copy = {};
        Object.keys(match).forEach(function(key) {
          copy[key] = actual[key];
        });
        return copy;
      }
      return actual;
    }
    module.exports = actualForMatch;
  });

  // lib/assertions/match.js
  var require_match2 = __commonJS((exports, module) => {
    "use strict";
    var samsam = require_samsam();
    var actualForMatch = require_actual_for_match();
    module.exports = function(referee) {
      referee.add("match", {
        assert: function(actual, matcher) {
          return samsam.match(actual, matcher);
        },
        assertMessage: "${customMessage}${actual} expected to match ${expected}",
        refuteMessage: "${customMessage}${actual} expected not to match ${expected}",
        expectation: "toMatch",
        values: function(actual, matcher, message) {
          return {
            actual: actualForMatch(actual, matcher),
            expected: matcher,
            customMessage: message
          };
        }
      });
    };
  });

  // lib/assertions/near.js
  var require_near = __commonJS((exports, module) => {
    "use strict";
    module.exports = function(referee) {
      referee.add("near", {
        assert: function(actual, expected, delta) {
          return Math.abs(actual - expected) <= delta;
        },
        assertMessage: "${customMessage}Expected ${actual} to be equal to ${expected} +/- ${delta}",
        refuteMessage: "${customMessage}Expected ${actual} not to be equal to ${expected} +/- ${delta}",
        expectation: "toBeNear",
        values: function(actual, expected, delta, message) {
          return {
            actual,
            expected,
            delta,
            customMessage: message
          };
        }
      });
    };
  });

  // lib/assertions/same.js
  var require_same = __commonJS((exports, module) => {
    "use strict";
    var samsam = require_samsam();
    var actualAndExpectedMessageValues = require_actual_and_expected_message_values();
    module.exports = function(referee) {
      referee.add("same", {
        assert: function(actual, expected) {
          return samsam.identical(actual, expected);
        },
        assertMessage: "${customMessage}${actual} expected to be the same object as ${expected}",
        refuteMessage: "${customMessage}${actual} expected not to be the same object as ${expected}",
        expectation: "toBe",
        values: actualAndExpectedMessageValues
      });
    };
  });

  // lib/assertions/tag-name.js
  var require_tag_name = __commonJS((exports, module) => {
    "use strict";
    var noTagNameMessage = "${customMessage}Expected ${actualElement} to have tagName property";
    module.exports = function(referee) {
      referee.add("tagName", {
        assert: function(element, tagName) {
          if (!element.tagName) {
            return this.fail(noTagNameMessage);
          }
          return tagName.toLowerCase && tagName.toLowerCase() === element.tagName.toLowerCase();
        },
        assertMessage: "${customMessage}Expected tagName to be ${expected} but was ${actual}",
        refuteMessage: "${customMessage}Expected tagName not to be ${actual}",
        expectation: "toHaveTagName",
        values: function(element, tagName, message) {
          return {
            actualElement: element,
            actual: element.tagName,
            expected: tagName,
            customMessage: message
          };
        }
      });
    };
  });

  // lib/assertions/json.js
  var require_json = __commonJS((exports, module) => {
    "use strict";
    var samsam = require_samsam();
    var parseErrorMessage = "${customMessage}Expected ${actual} to be valid JSON";
    module.exports = function(referee) {
      referee.add("json", {
        assert: function(actual, expected) {
          var parsed;
          try {
            parsed = JSON.parse(actual);
          } catch (e) {
            return this.fail(parseErrorMessage);
          }
          return samsam.deepEqual(parsed, expected);
        },
        assertMessage: "${customMessage}Expected ${actual} to equal ${expected}",
        refuteMessage: "${customMessage}Expected ${actual} not to equal ${expected}",
        expectation: "toEqualJson",
        values: function(actual, expected, message) {
          var parsed;
          try {
            parsed = JSON.parse(actual);
          } catch (e) {
          }
          return {
            actualRaw: actual,
            actual: parsed || actual,
            expected,
            customMessage: message
          };
        }
      });
    };
  });

  // lib/assertions/match-json.js
  var require_match_json = __commonJS((exports, module) => {
    "use strict";
    var samsam = require_samsam();
    var actualForMatch = require_actual_for_match();
    var parseErrorMessage = "${customMessage}Expected ${actual} to be valid JSON";
    module.exports = function(referee) {
      referee.add("matchJson", {
        assert: function(actual, matcher) {
          var parsed;
          try {
            parsed = JSON.parse(actual);
          } catch (e) {
            return this.fail(parseErrorMessage);
          }
          return samsam.match(parsed, matcher);
        },
        assertMessage: "${customMessage}Expected ${actual} to match ${expected}",
        refuteMessage: "${customMessage}Expected ${actual} not to match ${expected}",
        expectation: "toMatchJson",
        values: function(actual, matcher, message) {
          var parsed;
          try {
            parsed = JSON.parse(actual);
          } catch (e) {
          }
          parsed = actualForMatch(parsed, matcher);
          return {
            actualRaw: actual,
            actual: parsed || actual,
            expected: matcher,
            customMessage: message
          };
        }
      });
    };
  });

  // lib/create-async-assertion.js
  var require_create_async_assertion = __commonJS((exports, module) => {
    "use strict";
    var samsam = require_samsam();
    function createAsyncAssertion(thenFunc, catchFunc) {
      function asyncAssertion(promise) {
        var self2 = this;
        this.expected = arguments.length === 1 ? samsam.match.any : arguments[1];
        function applyCallback(callback, context) {
          return function(actual) {
            self2.actual = actual;
            try {
              callback.apply(context, [actual, self2.expected]);
            } catch (error) {
              context.reject(error.message);
            }
          };
        }
        var assertionPromise = new Promise(function(resolve, reject) {
          try {
            var context = {resolve, reject};
            promise.then(applyCallback(thenFunc, context), applyCallback(catchFunc, context));
          } catch (error) {
            reject(error.message);
          }
        }).catch(function(message) {
          self2.fail(message);
        });
        return assertionPromise;
      }
      return asyncAssertion;
    }
    module.exports = createAsyncAssertion;
  });

  // lib/assertions/resolves.js
  var require_resolves = __commonJS((exports, module) => {
    "use strict";
    var samsam = require_samsam();
    var createAsyncAssertion = require_create_async_assertion();
    var assertMessage = "${actual} is not equal to ${expected}";
    var refuteMessage = "${actual} is equal to ${expected}";
    module.exports = function(referee) {
      function catchCallback() {
        this.reject("${0} did not resolve, it rejected instead");
      }
      referee.add("resolves", {
        assert: createAsyncAssertion(function(actual, expected) {
          if (!samsam.deepEqual(actual, expected)) {
            this.reject(assertMessage);
            return;
          }
          this.resolve();
        }, catchCallback),
        refute: createAsyncAssertion(function(actual, expected) {
          if (samsam.deepEqual(actual, expected)) {
            if (expected === samsam.match.any) {
              this.reject("${0} resolved unexpectedly");
            } else {
              this.reject(refuteMessage);
            }
            return;
          }
          this.resolve();
        }, catchCallback),
        expectation: "toResolveWith",
        assertMessage,
        refuteMessage
      });
    };
  });

  // lib/assertions/rejects.js
  var require_rejects = __commonJS((exports, module) => {
    "use strict";
    var samsam = require_samsam();
    var createAsyncAssertion = require_create_async_assertion();
    var assertMessage = "${actual} is not equal to ${expected}";
    var refuteMessage = "${actual} is equal to ${expected}";
    module.exports = function(referee) {
      function thenCallback() {
        this.reject("${0} did not reject, it resolved instead");
      }
      referee.add("rejects", {
        assert: createAsyncAssertion(thenCallback, function(actual, expected) {
          if (!samsam.deepEqual(actual, expected)) {
            this.reject(assertMessage);
            return;
          }
          this.resolve();
        }),
        refute: createAsyncAssertion(thenCallback, function(actual, expected) {
          if (samsam.deepEqual(actual, expected)) {
            if (expected === samsam.match.any) {
              this.reject("${0} rejected unexpectedly");
            } else {
              this.reject(refuteMessage);
            }
            return;
          }
          this.resolve();
        }),
        expectation: "toRejectWith",
        assertMessage,
        refuteMessage
      });
    };
  });

  // lib/referee.js
  var require_referee = __commonJS((exports, module) => {
    "use strict";
    var ee = require_event_emitter();
    var referee = ee();
    referee.add = require_create_add()(referee);
    referee.assert = require_create_assert()(referee);
    referee.refute = require_create_refute()(referee);
    referee.expect = require_create_expect()(referee);
    referee.fail = require_create_fail()(referee);
    referee.pass = require_create_pass()(referee);
    referee.verifier = require_create_verifier()(referee);
    referee.equals = require_samsam().deepEqual;
    referee.match = require_samsam().createMatcher;
    require_class_name2()(referee);
    require_contains2()(referee);
    require_equals()(referee);
    require_exception()(referee);
    require_greater()(referee);
    require_has_arity()(referee);
    require_has_prototype()(referee);
    require_is_array()(referee);
    require_is_array_buffer()(referee);
    require_is_array_like()(referee);
    require_is_boolean()(referee);
    require_is_data_view()(referee);
    require_is_date2()(referee);
    require_is_error()(referee);
    require_is_eval_error()(referee);
    require_is_false()(referee);
    require_is_float_32_array()(referee);
    require_is_float_64_array()(referee);
    require_is_function()(referee);
    require_is_infinity()(referee);
    require_is_int_8_array()(referee);
    require_is_int_16_array()(referee);
    require_is_int_32_array()(referee);
    require_is_intl_collator()(referee);
    require_is_intl_date_time_format()(referee);
    require_is_intl_number_format()(referee);
    require_is_map2()(referee);
    require_is_nan2()(referee);
    require_is_null()(referee);
    require_is_negative_infinity()(referee);
    require_is_number()(referee);
    require_is_object2()(referee);
    require_is_promise()(referee);
    require_is_range_error()(referee);
    require_is_reference_error()(referee);
    require_is_reg_exp()(referee);
    require_is_set2()(referee);
    require_is_string()(referee);
    require_is_symbol()(referee);
    require_is_syntax_error()(referee);
    require_is_true()(referee);
    require_is_type_error()(referee);
    require_is_undefined()(referee);
    require_is_uri_error()(referee);
    require_is_u_int_16_array()(referee);
    require_is_u_int_32_array()(referee);
    require_is_u_int_8_array()(referee);
    require_is_u_int_8_clamped_array()(referee);
    require_is_weak_map()(referee);
    require_is_weak_set()(referee);
    require_keys2()(referee);
    require_less()(referee);
    require_match2()(referee);
    require_near()(referee);
    require_same()(referee);
    require_tag_name()(referee);
    require_json()(referee);
    require_match_json()(referee);
    require_resolves()(referee);
    require_rejects()(referee);
    module.exports = referee;
  });
  require_referee();
})();
